[{"content":"Overview This writeup details the construction of rudimentary machine learning models that use the descriptions of CVEs to predict their corresponding base CVSS scores. A brief illustration is shown below.\nThe original idea originates from an internship that I have done, and this personal project is an attempt on my own to improve and expand on what I done previously. The project is still a work in progress.\nPython and its associated libraries (mainly Pandas, Sklearn and some SpaCy) are used.\nRaw Data Gathering and Filtering Data for this project is taken from CVE JSON data feeds provided by the National Vulnerability Database (NVD). Each data feed contains details of CVEs in a particular year, with the earliest data feed coming from the year 2002. The JSON data feeds contain tons of data about each CVE, such as the CWEs associated with it, references, descriptions, CVSS V2 and V3 metrics, and published dates.\nAs the JSON data feeds are quite complex, they cannot be easily parsed into a dataframe using Pandas and Python\u0026rsquo;s json library due to their extremely nested structure and missing fields when data is absent. Thus, I decided to just extract the essential data (CVE description, base CVSS V2 score, and base CVSS V3 score) that will be needed from the data feeds instead of trying to parse all data into a nice dataframe. Since not every CVE has an associated CVSS V2 or V3 score, missing scores are temporarily replaced with a None when extracting these data. The function used is shown here:\ndef get_useful_features(raw_cve_entry): entry = dict() try: entry[\u0026#34;description\u0026#34;] = raw_cve_entry[\u0026#34;cve\u0026#34;][\u0026#34;description\u0026#34;][\u0026#34;description_data\u0026#34;][0][\u0026#34;value\u0026#34;] except KeyError: entry[\u0026#34;description\u0026#34;] = None try: entry[\u0026#34;baseScoreV3\u0026#34;] = raw_cve_entry[\u0026#34;impact\u0026#34;][\u0026#34;baseMetricV3\u0026#34;][\u0026#34;cvssV3\u0026#34;][\u0026#34;baseScore\u0026#34;] except KeyError: entry[\u0026#34;baseScoreV3\u0026#34;] = None try: entry[\u0026#34;baseScoreV2\u0026#34;] = raw_cve_entry[\u0026#34;impact\u0026#34;][\u0026#34;baseMetricV2\u0026#34;][\u0026#34;cvssV2\u0026#34;][\u0026#34;baseScore\u0026#34;] except KeyError: entry[\u0026#34;baseScoreV2\u0026#34;] = None return entry The extracted essential data can be seen below.\nAfter extracting the data, a quick look at the data will show that there are many unusable CVEs that are included in the data (See row 177474 in the figure above). The different reasons for the CVEs to be not usable is shown below, along with the number of CVEs that is tagged with that reason.\n   Reason for not being used Number of CVEs     REJECT 10349   DISPUTED 897   UNSUPPORTED WHEN ASSIGNED 91   PRODUCT NOT SUPPORTED WHEN ASSIGNED 6   UNVERIFIABLE 5   UNVERIFIABLE, PRERELEASE 2   SPLIT 1    Since they all had a description that starts with ** \u0026lt;REASON\u0026gt; **, a quick regex matching was done to filter out and remove these unneeded data.\ndf = df[~(df.description.str.contains(\u0026#39;^\\\\*\\\\*\\\\s+[A-Z]+\\\\s+\\\\*\\\\*\\\\s+\u0026#39;))] # Remove unneeded CVEs Initially, I thought of using both base CVSS V2 and V3 scores in the project, simply to see which score can be better predicted. However, after looking at the counts of each metric, I realised that the number of CVEs with base CVSS V2 scores (165904) vastly outnumbered the number of CVEs with base CVSS V3 scores (92983). As such, I then decided to remove all CVEs that do not have a base CVSS V2 score and just focus on predicting base CVSS V2 scores, simply as that would allow me more data to work with.\ndf.dropna(inplace=True, subset=[\u0026#34;baseScoreV2\u0026#34;]) After the removal of unusable CVEs and CVEs that do not have an associated base CVSS V2 score, I was left with a total of 165904 rows of CVE entries, shown below.\nThe CVE entries are then split into train and test data.\nX = df[\u0026#34;description\u0026#34;] y = df[\u0026#34;baseScoreV2\u0026#34;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) The distribution of base CVSS V2 scores of the training data is shown below.\nML Pipeline Construction Since I have filtered out all unneedded data, I can proceed to create the ML pipelines. The pipelines will consists of 3 steps:\n Vectorizer to convert CVE descriptions into a vector form suitable to be fed into ML algorithms. An optional PCA algorithm to reduce the dimensions of the input from the vectorizer. The actual ML model that will be used.  NLP Processing and Vectorizing Firstly, I chose the easy way out and used the Bag-of-Words (BoW) and TF-IDF models to vectorize the descriptions. These 2 models can be invoked by simply using Sklearn\u0026rsquo;s CountVectorizer and TfidfVectorizer. To augment these vectorizers, I used SpaCy to write a custom tokenizer function to do basic NLP processing on these descriptions which can be fed into Sklearn\u0026rsquo;s vectorizers. The Python library SpaCy is used for this purpose since it contains pretrained NLP pipelines which simplifies this processing step immensely.\n# Create custom tokenizer def tokenizer(desc): tokens = nlp(desc) tokens = [word.lemma_.lower().strip() for word in tokens] tokens = [word for word in tokens if word not in nlp.Defaults.stop_words and not set(word).issubset(punctuation)] return tokens The function first feeds each description into SpaCy\u0026rsquo;s en_core_web_lg pretrained pipeline, where they are tokenized. Then, each token is stripped off leading and trailing whitespaces, before being converted to lowercase and lemmatized. If the token is a punctuation or a stop word, it is removed too. The result is then a list of tokens that will be used by Sklearn\u0026rsquo;s vectorizers to fit the BoW and TF-IDF models. The output of the vectorizers will then be a word vector that represents the CVE description that was fed in.\nThe vectorizers and parameters used are shown below:\nCountVectorizer(tokenizer=tokenizer, ngram_range=(1,2), max_df=0.5, min_df=5, max_features=10000,) TfidfVectorizer(tokenizer=tokenizer, ngram_range=(1,2), max_df=0.5, min_df=5, max_features=10000,) PCA for Dimensionality Reduction As the dimensions of the word vectors are very large due to the large vocabulary accumulated from all the training CVE descriptions, PCA is used reduce the number of dimensions of the word vectors. However, as including this step increases the computational time by a lot, this step is ommitted in most of the pipelines that I created.\nTruncatedSVD(n_components=10000, n_iter=7, random_state=42) Choosing ML Models Since my aim is just to explore which ML model will give a better result, I chose a few simple models to get a basic feel of how well a model can predict the base CVSS V2 scores using their associated CVE descriptions (The models were also chosen with considerations for my potato laptop).\nModels chosen were:\n Linear Regression KNN Decision Trees Gradient Boosting Regression (Xgboost)  With the exception of Linear Regression which was fitted on transformed features from both BoW and TF-IDF vectorizers, the other 3 models were only fitted on transformed data from the TF-IDF vectorizer.\nlinear_regr = LinearRegression() knn_regr = KNeighborsRegressor() dt_regr = DecisionTreeRegressor(min_samples_split=5, min_samples_leaf=3,) xgboost_regr = GradientBoostingRegressor() Results To score results of the models, Mean Square Error was chosen as the evaluation metric, since I want to penalize models more for larger errors. As the target base CVSS V2 score only ranges from 0 to 10, the predicted values of the models are further fed into a function that constrains the predicted values to this range (predicted values that are less than 0 to 0, and all predicted values more than 10 to 10).\ny_pred = np.clip(pipeline.predict(X_test), 0, 10) mse = mean_squared_error(y_test, y_pred) Results are shown in the table below. Do note fine tuning of models have not been done as of the writing of this writeup since it is probably going to take a long time to run and burn up my laptop.\n   Model Vectorizer Have PCA MSE     Linear Regression BoW False 1.62   Linear Regression TF-IDF False 1.66   Linear Regression BoW True 1.59   KNN TF-IDF False 1.92   Decision Trees TF-IDF False 2.22   Xgboost TF-IDF False 1.91    Discussion and Future Work As can be seen, the BoW vectorizer seem to produce slightly better results than the TF-IDF vectorizer. Inclusion of the PCA algorithm also provides some slight improvements. Comparing the different models used, linear regression seem to have produced the best results.\nOverall, the best MSE of 1.59 is a good sign, especially since the pipelines are not optimised at all. This shows that the ML model will on average have an error of about 1.59 when prediciting CVSS scores, which is still acceptable since 1.59 is not too much over the range of 0 to 10.\nIn the future, work will be done in the following aspects:\n Constructing a recurrent neural network to compare against the performance of these classic ML algorithms. Perform more pre-processing on the CVSS scores, since they are not very normally distributed. Incorporate word vectors and compare performance against the BoW and TF-IDF vectorizers. Optimising hyperparameters to get an optimal model. Employing the model for various use cases.  References  https://nvd.nist.gov/vuln/data-feeds# https://scikit-learn.org/stable/modules/classes.html https://pandas.pydata.org/docs/ https://spacy.io/usage/linguistic-features https://www.kaggle.com/nkitgupta/text-representations https://www.kaggle.com/abhishek/approaching-almost-any-nlp-problem-on-kaggle https://www.ibm.com/support/pages/transforming-variable-normality-parametric-statistics https://towardsdatascience.com/working-with-sparse-data-sets-in-pandas-and-sklearn-d26c1cfbe067  ","permalink":"https://nusgreyhats.org/posts/writeups/simple-ml-models-to-predict-cvss-scores/","summary":"Overview This writeup details the construction of rudimentary machine learning models that use the descriptions of CVEs to predict their corresponding base CVSS scores. A brief illustration is shown below.\nThe original idea originates from an internship that I have done, and this personal project is an attempt on my own to improve and expand on what I done previously. The project is still a work in progress.\nPython and its associated libraries (mainly Pandas, Sklearn and some SpaCy) are used.","title":"Simple ML models to predict CVSS scores"},{"content":"An introduction to Digital Forensics Welcome to a beginner\u0026rsquo;s guide to Digital Forensics. This writeup explains how forensics is applied in the real world, and common techniques/challenges used in CTFs.\nIf you are already well versed with digital forensics and would like to learn about digital forensics in CTFs, you may skip to here.\nThe term \u0026ldquo;forensics\u0026rdquo; originally means \u0026ldquo;of or before the forum\u0026rdquo;. The modern meaning of \u0026ldquo;forensics\u0026rdquo; is a form of legal evidence to be presented.\nDigital Forensics There are multiple aspects of digital forensics. They include but are not limited to:\n File System Forensics Memory Forensics Network Forensics Database Forensics Application Forensics E-mail Forensics  In this writeup, we will be focusing on file system forensics, memory forensics, and network forensics.\nFile System Forensics Files or folders can be hidden by:\n having their names start with . (in Linux) marking them as hidden (in Windows) deleting them  Deleted files can potentially be recovered through data carving using specific tools. Data carving is the process of reassembling computer files from fragments in the absence of filesystem metadata.\nWhen a file is deleted, the entry in the file system metadata is removed. However, the actual data still remains on the disk. The data is only lost after is is overwritten by new data. This is why in digital forensics, it is important to not write new data into the medium that you are carrying out forensics on.\nLet me explain this in simpler terms.\nImagine you have a folder containing many sheets of papers. The first page of the folder is a contents page. In real life, when you want to remove a piece of paper from the file permanently, you will simply do so. However, that is not the case for computers. In computers, what happens is that the entry in the contents page gets erased, while the piece of paper inside the file remains untouched. When you need to write new information into the folder, the pages with the unwanted content gets overwritten with new information, while what remains of the old, unwanted information gets ignored.\nMemory Forensics Hard disks contain a myriad of data. They not only contain data of your files and folders, but also store much more information that most people aren\u0026rsquo;t aware about. These essential groups of data contain metadata and other bits of information that makes a hard drive behave correctly. Chunks of space in hard drives are reserved for metadata.\nHowever, not all of the space in those chunks are actually utilized. This allows for data to be written and hidden in these empty spaces, and will not affect the typical functionality of the hard drive in any way. Examples of parts of the hard drive where data can be hidden in are:\n Host Protected Area \u0026amp; Device Configuration Overlay Unused space in the Master Boot Record Volume Slack Partition Slack Boot sector in Non-bootable partition Unallocated space in a partition Good blocks marked \u0026ldquo;bad\u0026rdquo; Disk Slack Unused space in superblock Unused space in block groups Directory entries  Data hidden in these areas of a hard disk can be found through the process of data carving.\nNetwork Forensics Network traffic is extremely volatile. This is why network forensics should be a proactive investigation.\nHow to capture network traffic? To capture network traffic, run a network monitoring tool such as Wireshark.\nWhere to capture network traffic? Network traffic should be captured at an endpoint, such as a proxy server, or at a forensic PC connected to the mirror port of an internet router.\nAt these locations, investigators can collect unicast traffic sent from the host in question.\nComputer networks have layers In computer networking, there are several layers. Namely, the application, transport, network, and data-link layers. Each layer employs different protocols to ensure that data moves from one place to another correctly. This also means that there are different types of evidence we can collect from each layer.\nApplication Layer  DNS, SMTP, HTTPS and HTTP protocols are used in this layer.  DNS translates a domain name into the correct IP address. SMTP is used to send and receive mail. HTTPS is the secure version of HTTP, and is used to fetch HTML files to load web pages.    HTTP is not secure because the data is sent in plain text. This means that if a malicious actor gained unlawful access into a network (or if they are in the vicinity of the victim), and if a user enters their login details to gain access to their own account on a certain website, the malicious actor will be able to acquire them by sniffing the packets on the network sent by the unsuspecting user. HTTPS fixes that problem by encrypting data being received and sent by a host, and is still in use to this day since its introduction in 1994.\nTransport Layer The transport layer optionally ensures the reliability of communications. TCP and UDP are used here.\n TCP is used in connections where reliability is of paramount importance. For example, in sending texts, streaming videos, or sending files. UDP is used in connections where speed takes precedence over reliability. For example, in voice/video calls, or when playing online games.  Network Layer The network layer is in charge of routing packets across networks.\nThe IP protocol delivers packets from the source host to destination host based on the IP addresses present in packet headers.\nData-link layer The data-link layer is responsible for handling communications on the physical network components.\nWith the right expertise and tools, it is possible to eavesdrop on wired communications that go through ethernet cables.\nNetwork Forensics as a whole At the beginning of network forensics, investigators begin with very limited information such as an IP address, port number, and a protocol.\nHowever, this is enough to search for more sources of data for more useful information. Most of the time, the more useful evidence is found in the application layer.\nDespite this, investigators might still need additional IP addresses to identify other hosts involved in the malicious activity. Certain activities such as DDoS attacks do not have relevant application-level data.\nTherefore, network forensics provides important support to the overall analysis of activities happening in the application layer.\nForensics in CTFs In CTFs, forensics is a very popular category. It is also important to note that while some challenges may be marked as \u0026ldquo;forensics\u0026rdquo;, they may also employ steganography and/or cryptography to make them even more challenging.\nSteganography involves hiding data, while cryptography makes it difficult to understand the data. More often than not, you might find yourself going deep into rabbit holes that lead to absolutely nowhere. It may be frustrating, but it\u0026rsquo;ll feel very rewarding once you get the flag.\nHere are some tips you can use to get started with common/easy forensics challenges.\nImage Forensics Hidden in plain sight  Sometimes, information can be hidden in plain sight, just like in this example\n On the left is an image downloaded from a challenge. On the right is the same image but filled with white, which reveals a hidden URL in a slightly different tone of red.\nMetadata Instead of data being hidden inside the image, they might be hidden in the metadata. By viewing the properties of the file or by using an online tool such as Jeffrey\u0026rsquo;s Image Metadata Viewer, we will be able to see these information.\nHidden strings  Potential flag hidden in the image file, when viewed using HxD, a hex editing software\n When viewed in a text or hex editor, images may contain strings like these. These strings, when placed in certain parts of the file, will not affect the image in any way. This means that the image can still be opened and viewed normally using an image viewer.\nIn Linux systems, there is a command called strings. You can also run this command with the given file to see if there are any readable secrets.\nHidden Files  Hidden files found and extracted from a file using binwalk\n Similar to hiding a string, files can also be hidden in images. They are typically concatenated after the bytes of the image. They can be found and extracted using tools such as binwalk.\nLeast Significant Bit (LSB) As you know, files are made up of bytes. 1 byte is equal to 8 bits. If the least significant bit of a byte is changed, it will not change the overall value by too much.\nUsing this idea, we can potentially hide messages in binary in images by altering the LSB of all the pixel values. This will not make any significant change to the image, and will practically go unnoticed by humans.\nTo extract the hidden information, simply go through all the bytes, take the LSB, and append it to the string of extracted LSBs. Then, convert the final binary string into a readable message or even a file.\nTo learn more about LSB Steganography, this tutorial provides a more in-depth explanation of how it works.\nAudio Forensics Binary or Morse Code A peak in a soundwave may denote a 1, while a trough may denote a 0. This is a simple way to hide messages encoded in binary or Morse code in an audio file.\n Screenshot of a Forensics challenge, where the high represents 1, and the low represents 0.\n For challenges like this, a visual aid might be useful. I recommend opening the file in Audacity first before conducting further analysis.\nSpectrogram Even though it is an audio file that you\u0026rsquo;re dealing with, the challenge author might want to hide visual information in the sound. Not in the form of waves, but through spectrograms.\n QR Code hidden in spectrogram\n One way to view spectrograms in audio files is through this online tool called Spectrum Analyzer.\nNetwork Forensics Hidden in plain sight  HTTP sends unencrypted packets from one endpoint to another, making it incredibly unsecure\n Given a packet capture (pcap) file, you can find out what has been done, and what has been communicated over two hosts.\nFirstly, open the pcap file in Wireshark. For simpler challenges, the flags can be present in plain text— you\u0026rsquo;ll just need to know what to look for.\nUnsecured protocols such as HTTP should first be used as filters to get the low-lying fruit.\nFollow the TCP Stream On a given pcap file, there might be a need to extract messages or files that have been sent from one host to another. This can be done by following a TCP stream, then saving the contents of the stream.\nIf there are multiple types of files in the packet capture, you may want to check out this guide on how to export objects from different types of traffic in Wireshark.\nUnknown file Forensics Identify file signature What happens when you are given a file with an unknown extension, or even one that doesn\u0026rsquo;t exist?\nLuckily, files always have two attributes we can use to identify them. The first way is through the extension (png, jpg, mp4, wav, pdf, etc.). The second way is through file signatures.\nA file signature is a unique group of bytes located at the beginning of a file. File signatures are used to identify or verify the content of a file.\nHere is a list of file signatures you can use to figure out what type of file you are dealing with.\nAlternatively, you may also run file or binwalk on the unknown file to identify it automatically.\nBroken file signatures Uh oh, you realised that the extension of the given file is unknown, and the signature does not exist in the given list. Now what?\nAt this point, you may check if there are any similarities between the broken signature you were given, and legitimate signatures. Chances are, you might just need to fix a few bytes here and there before the file becomes readable.\nConversely, the file signature might be legitimate, but the file extension isn\u0026rsquo;t. In such cases, simply change the extension to the one that corresponds to the file signature, and you\u0026rsquo;ll be able to open the file.\nOS Forensics Event Logs  A security log entry depicting a logon event in Event Viewer\n Login time, number of failed password attempts, last logon attempt, and other security \u0026amp; system related logs can be found in the Event Viewer of Windows machines. They may provide useful information on what last went down in a computer system.\nBrowser Artifacts Browser history, passwords, cookies, temporary internet files, and bookmarks might prove to be useful in an investigation. Be sure to check these if you are given a snapshot of an operating system and need to look for clues.\nUser Directories Operating systems may contain different profiles. If what you are looking for is not present in the current user\u0026rsquo;s directory, chances are that you might be looking in the wrong place.\nTry going to other users' home directories to see if there are any files of interest.\nHidden Directories/Files  A directory in windows with the \u0026ldquo;Hidden\u0026rdquo; attribute\n Still can\u0026rsquo;t find what you are looking for? That might be a sign that some data cannot be seen through normal means.\nIn Windows' File Explorer, check that View -\u0026gt; Hidden Items is enabled. This allows you to see hidden files and folders.\nIn Linux machines, files and folders may be renamed to begin with ., which will be ignored by the ls command. To show these hidden items, use ls -a instead.\nConclusion There are many more aspects of digital forensics that were not covered in this writeup, as it was meant to be a brief introduction for beginners. I personally recommend trying the challenges over at ctflearn.com for beginner-level ones. I hope you\u0026rsquo;ve enjoyed reading and have hopefully learnt something new! :)\nReferences File system forensics:\n https://en.wikipedia.org/wiki/File_carving  Memory Forensics:\n http://www.berghel.net/publications/data_hiding/data_hiding  Network Forensics:\n https://en.wikipedia.org/wiki/Network_forensics http://testphp.vulnweb.com/login.php  Audio Forensics:\n https://ctf-wiki.mahaloz.re/misc/audio/introduction/  Forensics Tools/Guides/References for CTFs Image Forensics:\n https://ctflearn.com/challenge/934 https://ctflearn.com/challenge/108 http://exif.regex.info/exif.cgi https://stylesuxx.github.io/steganography/ https://www.file-recovery.com/jpg-signature-format.htm https://ctf101.org/forensics/what-is-stegonagraphy/  Unknown File Forensics:\n https://www.easytechjunkie.com/what-is-a-file-signature.htm https://www.kali.org/tools/binwalk/  ","permalink":"https://nusgreyhats.org/posts/writeups/introduction-to-digital-forensics/","summary":"An introduction to Digital Forensics Welcome to a beginner\u0026rsquo;s guide to Digital Forensics. This writeup explains how forensics is applied in the real world, and common techniques/challenges used in CTFs.\nIf you are already well versed with digital forensics and would like to learn about digital forensics in CTFs, you may skip to here.\nThe term \u0026ldquo;forensics\u0026rdquo; originally means \u0026ldquo;of or before the forum\u0026rdquo;. The modern meaning of \u0026ldquo;forensics\u0026rdquo; is a form of legal evidence to be presented.","title":"Introduction to Digital Forensics"},{"content":"Overview The HTX Investigators’ Challenge (HTXIC) 2021 was a CTF competition with about ~128 teams participating, it was held online on 20 Dec 2021. This post will document a writeup on the challenge Reversing 101 as I thought it is quite a fun to reverse a tic tac toe game and find flag.\n  PS: The CTF came in a mixed reality/game world concept where instead of the usual web portal where we submit our flags, it is done in a Unity game mirroring the HTX Office in real life. We get to see our teammates in game too in various avatars and have to uncover/hunt for \u0026lsquo;quests\u0026rsquo; in game to unlock the CTF challenges. Other than the lack of features in-game like the ability to chat, this CTF was quite a novel one replacing the face to face physical competitions in this COVID-19 pandemic.\nUnderstanding the binary Since the challenge title already hints that this is a reversing challenge, we can first analyse the binary to know what we are dealing with.\nUploading the file onto VirusTotal is a easy way to figure it, so upon upload we get the following:\n  Access the full VirusTotal Report here\nIndicating that this binary is a PE32 executable for MS Windows (GUI) Intel 80386 32-bit Mono/.Net assembly.\n  We can verify this using local tools as well, for example on Detect It Easy, identifying it to be a .NET(v4.0.30319) binary. This would mean that we can test this binary out on a Windows VM. Interestingly, Confuser(1.X) was also identified, this will be useful later.\nTesting the binary Before going into reversing the program, let\u0026rsquo;s first understand what it does.\n  Launching the program, we expectedly get a GUI program showing a Tic Tac Toe game. The symbols and font of the game looks suspicious, and in the background a familiar soundtrack from the popular Squid Game Netflix drama is playing, perhaps a sign that this game is rigged and we have no way to legitimately win 😥😥.\n  After some testing of the game by manually playing the tic tac toe against the \u0026lsquo;AI\u0026rsquo;, and manipulating the game with some basic Cheat Engine, seems like even with a high score 1 million games won is not something that would reveal the challenge flag.\nBesides testing the game score, the game is pretty basic. Just click anywhere on the 3x3 game tile to play the game, after you win or lose, click next round. Alternatively, the score resets when you click on the \u0026lsquo;Reset\u0026rsquo; button. The game functions like how one would expect a typical tic tac toe game to, except you will never get a flag/prize even if you played beyond integer limit.\nLooks like the flag won\u0026rsquo;t come easily, and does require some 101 reversing efforts. So let\u0026rsquo;s get started.\nReversing the binary Since Detect It Easy has identified that this is a .NET application, we can make use of our handy dnSpy to deal with it. This tool is a useful debugger and .NET assembly editor and it does come with the feature to decompile .NET. This is great news, as we do not have to use tools like Ghidra or IDA Pro which would be more tedious to reverse and analyse.\n  Upon opening it on dnSpy, we can see that the code is successfully reversed. Unfortunately, we see some form of obfuscation, where things like the method names are not in plaintext.\n  This is due to the use of Confuser by the authors, which we have identified earlier. This technique is also commonly used by malware authors if they want to hinder analysis efforts. For this challenge, more specifically, it is ConfuserEx v1.0.0 which was used to obfuscate the binary. To solve this, we could use de4dot to clean up the binary.\nJust clone the GitHub and compile it, or grab a release on the internet. Then just run the command:\nPS C:\\Users\\Alice\\Desktop \u0026gt; de4dot-x64.exe .\\TicTacToe.exe de4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com Latest version and source code: https://github.com/0xd4d/de4dot Detected Unknown Obfuscator (C:\\Users\\Alice\\Desktop\\TicTacToe.exe) Cleaning C:\\Users\\Alice\\Desktop\\TicTacToe.exe Renaming all obfuscated symbols Saving C:\\Users\\Alice\\Desktop\\TicTacToe-cleaned.exe   Finally, the code is cleaned and readable. The code is quite long, with about 1000++ lines in total. So I will just summarize what are the main points to solving this challenge.\nFirstly, at the entry point, it runs Form1 which is the main Tic Tac Toe game interface we saw earlier.\nprivate static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } Tracing the click events, we see that for each tile of the tic tac toe clicked by the user, the code is as follows:\nprivate void button1_Click(object sender, EventArgs e) { if (!this.bool_0) { if (this.list_0.Contains(\u0026#39;1\u0026#39;)) { this.button1.ForeColor = Color.Lime; this.button1.Text = \u0026#34;O\u0026#34;; this.list_0.Remove(\u0026#39;1\u0026#39;); this.method_8(); } } else { this.method_10(\u0026#39;1\u0026#39;); this.method_11(); } }   In method_8, it does a series of if else conditions to check if the player has won the game, lost it, or if it ended in a draw, and displays the message box accordingly.\nThis can be confirmed by base64 decoding:\necho WW91IHdpbiEgUHJlc3MgTmV4dCBSb3VuZCB0byBjb250aW51ZS4= | base64 --decode You win! Press Next Round to continue. echo WW91IExvc2UhIFByZXNzIE5leHQgUm91bmQgdG8gY29udGludWUu | base64 --decode You Lose! Press Next Round to continue. echo RHJhdyEgUHJlc3MgTmV4dCBSb3VuZCB0byBjb250aW51ZS4= | base64 --decode Draw! Press Next Round to continue. However, there is an additional if statement after the checks for win/lose/draw condition, checking if 2 integers are 3 and 2 respectively.\nif (this.int_0 == 3 \u0026amp;\u0026amp; this.int_1 == 2) { this.method_9(); } Turns out that this is referring to the player score. So let\u0026rsquo;s go back to the binary and give it a play.\n  To speed things up a little, as the AI was too dumb to win me, I edited the memory to give it the desired scores of 3 and 2 for myself and the AI. This could be played manually too, though time consuming.\nUpon clicking any tiles with the score, the condition is met and a message box pops up telling us \u0026ldquo;You have accessed the hidden locker, can you unlock it?\u0026rdquo;. How fun, we have unlocked a secret stage to this game.\nClearly, this is also hinting to us that we are closer to the flag now.\nHidden Locker (Secret Stage?!) in the binary   Now, the GUI of the .NET binary has changed. This is no longer a tic tac toe game but we have a PIN pad.\nThe code does something along the lines of:\n Checking the length of the PIN to be 9 Calling method 12, which checks our PIN  private void buttonX_Click(object sender, EventArgs e) { if (!this.bool_0) { if (this.list_0.Contains(\u0026#39;1\u0026#39;)) { this.button1.ForeColor = Color.Lime; this.button1.Text = \u0026#34;O\u0026#34;; this.list_0.Remove(\u0026#39;1\u0026#39;); this.method_8(); } } else { this.method_10(\u0026#39;1\u0026#39;); this.method_11(); } } public void method_11() { if (this.string_0.Length == 9) { this.method_12(); } }   From here, we see that it uses the PIN along with strings in the method Y0uSh0uldPr3ssth, 3butt0ns and TtH/04xZb79By/VnbPZlBgO/D96vRmqPk0QT50gbdi8= for AesCrypto. Now this is the crypto part of the reversing challenge.\nBut firstly, we have to ensure we pass the lengthy if condition for our PIN to even trigger the decryption routine. As it would be used for decryption, there is no point patching this binary to skip the statement as it would not give us the flag even if we manipulated the if condition.\nif (num % num9 == 0 \u0026amp;\u0026amp; num9 * 3 == num2 \u0026amp;\u0026amp; num2 * 3 == num4 \u0026amp;\u0026amp; num5 % num2 == 2 \u0026amp;\u0026amp; num6 * 4 == num5 \u0026amp;\u0026amp; num2 % num4 == num3 \u0026amp;\u0026amp; num2 - num6 == num \u0026amp;\u0026amp; num7 % num3 == num \u0026amp;\u0026amp; num7 / 2 == num6 \u0026amp;\u0026amp; num8 % num2 == num9 \u0026amp;\u0026amp; num8 % num7 == num2) Since this is something very painful (and perhaps impossible to do within the CTF 12 hours) to be done manually, I have decided to use some python scripting help along with z3 black magic.\nTo install, we can simply use pip.\npip install z3-solver Z3 is basically a theorem prover from Microsoft Research, this would help us to solve the equations given the amount of constraints imposed by the game. Please pardon me for my amateur z3 code, I am still learning it.\nfrom z3 import * s = Solver() pin_code = IntVector(\u0026#34;x\u0026#34;, 9) # Add constraints to z3 s.add(pin_code[0] % pin_code[8] == 0) s.add(pin_code[8] * 3 == pin_code[1]) s.add(pin_code[1] * 3 == pin_code[3]) s.add(pin_code[4] % pin_code[1] == 2) s.add(pin_code[5] * 4 == pin_code[4]) s.add(pin_code[1] % pin_code[3] == pin_code[2]) s.add(pin_code[1] - pin_code[5] == pin_code[0]) s.add(pin_code[6] % pin_code[2] == pin_code[0]) s.add(pin_code[6] / 2 == pin_code[5]) s.add(pin_code[7] % pin_code[1] == pin_code[8]) s.add(pin_code[7] % pin_code[6] == pin_code[1]) # Solve res = s.check() if res == sat: print(s.model()) else: print(\u0026#34;Response: %s\u0026#34; % res) Running the z3 solver would provide us the PIN, after doing some rearrangement:\nx__3 = 9 x__4 = 8 x__1 = 3 x__8 = 1 x__5 = 2 x__6 = 4 x__0 = 1 x__7 = 7 x__2 = 3 PIN = 133982471   Finally, with the PIN cracked, we can just enter it in the game using the GUI and a message box will appear giving us the flag!\nYou have obtained the flag! HTX{R3v3rsingCSh4rplsE4sy}\nGgwp.\nReferences https://ericpony.github.io/z3py-tutorial/guide-examples.htm\nhttps://github.com/ViRb3/z3-python-ctf\nhttps://rolandsako.wordpress.com/2016/02/17/playing-with-z3-hacking-the-serial-check/\nhttps://wiki.bi0s.in/reversing/analysis/dynamic/linux/z3/\nhttps://labs.f-secure.com/assets/BlogFiles/mwri-hacklu-2018-samdb-z3-final.pdf\nhttps://github.com/dnSpy/dnSpy\nhttps://github.com/de4dot/de4dot\nhttps://www.youtube.com/watch?v=TpdDq56KH1I\n","permalink":"https://nusgreyhats.org/posts/writeups/htxic-reversing-101/","summary":"Overview The HTX Investigators’ Challenge (HTXIC) 2021 was a CTF competition with about ~128 teams participating, it was held online on 20 Dec 2021. This post will document a writeup on the challenge Reversing 101 as I thought it is quite a fun to reverse a tic tac toe game and find flag.\n  PS: The CTF came in a mixed reality/game world concept where instead of the usual web portal where we submit our flags, it is done in a Unity game mirroring the HTX Office in real life.","title":"HTXIC CTF Reversing 101 Writeup"},{"content":"Overview This post will cover some details behind the recent Grafana vulnerability (CVE-2021-43798), which is a directory traversal bug allowing unauthenticated attackers to read files on the target server filesystem. This post will also discuss some real world scenario and attack surface of the Grafana.\nBrief Analysis on the Root Cause The detailed analysis can be found at the author\u0026rsquo;s blog here, I will only briefly cover it.\nAll API routes were defined in pkg/api/api.go , some require authentication like below:\nr.Get(\u0026#34;/plugins\u0026#34;, reqSignedIn, hs.Index) r.Get(\u0026#34;/plugins/:id/\u0026#34;, reqSignedIn, hs.Index) r.Get(\u0026#34;/plugins/:id/edit\u0026#34;, reqSignedIn, hs.Index) // deprecated \tr.Get(\u0026#34;/plugins/:id/page/:page\u0026#34;, reqSignedIn, hs.Index) While some does not require signed in, like below:\n// expose plugin file system assets \tr.Get(\u0026#34;/public/plugins/:pluginId/*\u0026#34;, hs.getPluginAssets) For the route at /public/plugins/:pluginId/*, it is handled by hs.getPluginAssets, which is defined in pkg/api/plugins.go:\n// getPluginAssets returns public plugin assets (images, JS, etc.) // // /public/plugins/:pluginId/* func (hs *HTTPServer) getPluginAssets(c *models.ReqContext) { pluginID := web.Params(c.Req)[\u0026#34;:pluginId\u0026#34;] plugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID) if !exists { c.JsonApiErr(404, \u0026#34;Plugin not found\u0026#34;, nil) return } requestedFile := filepath.Clean(web.Params(c.Req)[\u0026#34;*\u0026#34;]) pluginFilePath := filepath.Join(plugin.PluginDir, requestedFile) if !plugin.IncludedInSignature(requestedFile) { hs.log.Warn(\u0026#34;Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \u0026#34;+ \u0026#34;is not included in the plugin signature\u0026#34;, \u0026#34;file\u0026#34;, requestedFile) } // It\u0026#39;s safe to ignore gosec warning G304 since we already clean the requested file path and subsequently \t// use this with a prefix of the plugin\u0026#39;s directory, which is set during plugin loading \t// nolint:gosec \tf, err := os.Open(pluginFilePath) the rest are Omitted Line 5 is retrieving /public/plugins/(.*) as the pluginId, then pass to line 12 filepath.Clean to do sanitization, and concatenate in line 13, finally passed to os.Open in line 23 to read the contents.\nThe most interesting part is the comment at line 20:\n // It\u0026rsquo;s safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n If we check the document on the usage of filepath.Clean:\n  Point 4 is worthy to take note.\n replace \u0026ldquo;/..\u0026rdquo; by \u0026ldquo;/\u0026rdquo; at the beginning of a path\n What if the path does not start with /..? we can try it out:\n  It seems that filepath.Clean is not working as what the developers expect it to do, which leads to directory traversal and subsequently arbitrary file read.\nIt can be replicated in the docker environment as shown below (take note that the plugin should exist, otherwise you will get Plugin not found error. Luckily, Grafana has come with some default plugins. In the screenshot below, I am using Grafana\u0026rsquo;s welcome plugin):\n  Nginx Reverse Proxy Bypass On the day this vulnerability is getting hot amongst the security researchers (around 7th Dec, 2021), the vulnerability author posted a tweet as below:\n  But one day later, he retweeted:\n  So does Nginx help? we can set up the environment and try:\n  We are getting a 400 bad request.\nThe reason is simple: Nginx will do path normalization before it forwards the request to the backend. If the normalized URI is requesting beyond the web root directory, it will simply returns 400 bad request.\nIn the request above, /public/plugins/welcome/../../../../../../../../../../etc/passwd will be normalized into /../../../../../../../etc/passwd, hence, a 400 bad request is returned.\nBut does that mean Nginx will protect Grafana against this kind of path traversal attack? May not be. It depends on how you configure the proxy_pass entry. Before I cover that, here is an example:\n  We can see that our path traversal still succeed and read the content of the sdk.ts, which is located two directories above the welcome plugin directory.\nSo here is first point, which is covered in the Nginx document\n If proxy_pass is specified without a URI, the request URI is passed to the server in the same form as sent by a client when the original request is processed\n Scroll back and examine my Nginx configuration, noticed that my proxy_pass entry is defined as http://localhost:3000, without a URI, hence, the original request will be forwarded to the Grafana backend. And in the first place, since my original URI is /public/plugins/welcome/../../sdk.ts, even after normalization by Nginx, it is /public/sdk.ts, which is a valid URI, hence, Nginx will not complain about it either.\nThis allows us to read arbitrary files up to three directory above the plugin directories. But the default plugin directories is deep at /usr/share/grafana/public/app/plugins/{plugin_id}, even being able to traverse up by 3 directories, there aren\u0026rsquo;t many files to read.\nSo here is the second point, which is covered in this post\n URL consists of scheme:[//authority]path[?query][#fragment], and browsers don’t send #fragment. But how must a reverse proxy handle #fragment?\nNginx throws fragment off\n So what would happen if my URI is /public/plugins/welcome/#/../../../../../../../../../etc/passwd?\nNginx will process until /public/plugins/welcome/, and forward the entire URI to the Grafana backend, and leads to path traversal all the way up to the root directory:\n  Attack Surface under Grafana In this section, we try to examine the possible attack surface under Grafana when we are able to read files on the file system.\nGrafana Database We can try to read the database file, which is located at /var/lib/grafana/grafana.db by default, which is a sqlite database:\n  So, what is inside the Grafana database?\nuser table:   The password is hard to decrypt, using a slow hash algorithm with salt as defined in pkg/util/encoding.go:\n// EncodePassword encodes a password using PBKDF2. func EncodePassword(password string, salt string) (string, error) { newPasswd := pbkdf2.Key([]byte(password), []byte(salt), 10000, 50, sha256.New) return hex.EncodeToString(newPasswd), nil } user_auth_token: It seems that user_auth_token is also stored as one-way hash, as defined in /pkg/services/auth/auth_token.go:\nfunc hashToken(token string) string { hashBytes := sha256.Sum256([]byte(token + setting.SecretKey)) return hex.EncodeToString(hashBytes[:]) } I can\u0026rsquo;t think of a way to exploit this, if possible, please tell me =)\ndata_source:   The data_source tells Grafana where to pull the data from.\nFinally there is something that we can exploit. In /pkg/cmd/grafana-cli/commands/datamigrations/encrypt_datasource_passwords_test.go:\nfunc DecryptSecureJsonData(ds *models.DataSource) (map[string]string, error) { decrypted := make(map[string]string) for key, data := range ds.SecureJsonData { decryptedData, err := util.Decrypt(data, setting.SecretKey) if err != nil { return nil, err } decrypted[key] = string(decryptedData) } return decrypted, nil } util.Decrypt is defined in /pkg/util/encryption.go, you can re-use it to decrypt the encrypted password in the data source, or you can use the script here:\n  The secretkey is defined in the Grafana\u0026rsquo;s configuration file, which is located at /etc/grafana/grafana.ini, and it might contains other sensitive information as well. We will cover those next\nGrafana Configuration File Located at /etc/grafana/grafana.ini by default, which might contain several sensitive information. You can take a look at the default configuration file here and see what can be stored inside. I won\u0026rsquo;t go through them one by one.\ngrafana-image-renderer Apart from the various credentials that could be leaked from the Grafana\u0026rsquo;s configuration file, another worth-mentioning entry is the grafana-image-renderer\n[rendering] # Options to configure a remote HTTP image rendering service, e.g. using https://github.com/grafana/grafana-image-renderer. # URL to a remote HTTP image renderer service, e.g. http://localhost:8081/render, will enable Grafana to render panels and dashboards to PNG-images using HTTP requests to an external service. server_url = # If the remote HTTP image renderer service runs on a different server than the Grafana server you may have to configure this to a URL where Grafana is reachable, e.g. http://grafana.domain/. callback_url = # Concurrent render request limit affects when the /render HTTP endpoint is used. Rendering many images at the same time can overload the server, # which this setting can help protect against by only allowing a certain amount of concurrent requests. concurrent_render_request_limit = 30 grafana-image-renderer is a remote HTTP image rendering service, which you can ask the renderer to visit the Grafana panel, render into image and send to us.\nThe official guideline is to set up the grafana-image-renderer service inside a separate docker, and link it to the Grafana docker using Docker Compose like below:\nversion: '2' services: grafana: image: grafana/grafana:latest ports: - '3000:3000' environment: GF_RENDERING_SERVER_URL: http://renderer:8081/render GF_RENDERING_CALLBACK_URL: http://grafana:3000/ GF_LOG_FILTERS: rendering:debug renderer: image: grafana/grafana-image-renderer:latest ports: - 8081 Under this configuration, the renderer service is inaccessible from the Internet.\nHowever, there is another option to run it as a standalone Node.js application.\n  It seems that the service is also listening on the localhost, but actually it is accessible via public network interface:\n  Exposing a renderer that attackers can specify any host for it to visit is not that dangerous unless you are running an outdated renderer:\n  And without sandbox:\n  So RCE is achievable:\n  Reference https://grafana.com/blog/2021/12/08/an-update-on-0day-cve-2021-43798-grafana-directory-traversal/\nhttps://j0vsec.com/post/cve-2021-43798/\nhttps://mp.weixin.qq.com/s/dqJ3F_fStlj78S0qhQ3Ggw\nhttps://pkg.go.dev/path/filepath\nhttps://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/\nhttps://articles.zsxq.com/id_jb6bwow4zf5p.html\nhttps://articles.zsxq.com/id_baeb9hmiroq5.html\nhttps://github.com/jas502n/Grafana-CVE-2021-43798\nhttps://securitylab.github.com/research/in_the_wild_chrome_cve_2021_30632/\n","permalink":"https://nusgreyhats.org/posts/writeups/a-not-so-deep-dive-in-to-grafana-cve-2021-43798/","summary":"Overview This post will cover some details behind the recent Grafana vulnerability (CVE-2021-43798), which is a directory traversal bug allowing unauthenticated attackers to read files on the target server filesystem. This post will also discuss some real world scenario and attack surface of the Grafana.\nBrief Analysis on the Root Cause The detailed analysis can be found at the author\u0026rsquo;s blog here, I will only briefly cover it.\nAll API routes were defined in pkg/api/api.","title":"A (not so deep) Dive into Grafana CVE-2021-43798"},{"content":"Overview This is a straightforward and classic reverse engineering challenge. It is a windows console application that will validate user input and checks the flag entered. I will go into a bit more details since this is a write up for beginners rather than experienced reverse engineers.\n  Understanding the target The first step to reverse engineering is figuring out how the target binary is constructed. I don\u0026rsquo;t want to waste our time reversing a packer or .NET bytecodes in IDA. So, I used Detect It Easy to check the binary.\n  It\u0026rsquo;s written in C++ which may have some mangled functions and complicated classes. But it is not that bad to reverse engineer in a classic decompiler like IDA or Ghidra.\nDecompile Loading the binary in IDA, I can see most of the logic is actually written in the main method. That saved me a lot of time as there is not much structures or classes to worry about which tends to be the most time consuming part of reverse engineering a C++ program.\nAs the main method is fairly long, I will just copy paste the IDA decompilation output here.\nint __cdecl main(int argc, const char **argv, const char **envp) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-\u0026#34;+\u0026#34; TO EXPAND]  v3 = (char *)operator new(0x33ui64); v4 = sub_1400026E0(std::cout, (__int64)\u0026#34;Are you ready for [REDACTED]?\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v4, sub_1400028B0); std::istream::getline(std::cin, Str1, 40i64); if ( !strcmp(Str1, \u0026#34;nimic_interesant\u0026#34;) ) { strcpy_s(v3 + 34, 0x11ui64, Str1); // v3[34]+ nimic_interesant  memset(var_buf, 0, sizeof(var_buf)); sub_140002240((__int64)var_buf); // populate the var_buf  if ( (*((_BYTE *)\u0026amp;var_buf[2] + *(int *)(var_buf[0] + 4)) \u0026amp; 6) != 0 ) sub_1400026E0(std::cout, (__int64)\u0026#34;50 burpees\u0026#34;); *(_OWORD *)Str1 = 0i64; v13 = 0i64; v14 = 0i64; std::istream::read(var_buf, Str1, 34i64); *(_OWORD *)v3 = *(_OWORD *)Str1; *((_OWORD *)v3 + 1) = v13; *((_WORD *)v3 + 16) = v14; v6 = v3[34]; *v3 ^= v6; v3[1] ^= v3[35]; v3[2] ^= v3[36]; v3[3] ^= v3[37]; v3[4] ^= v3[38]; v3[5] ^= v3[39]; v3[6] ^= v3[40]; v3[7] ^= v3[41]; v3[8] ^= v3[42]; v3[9] ^= v3[43]; v3[10] ^= v3[44]; v3[11] ^= v3[45]; v3[12] ^= v3[46]; v3[13] ^= v3[47]; v3[14] ^= v3[48]; v3[15] ^= v3[49]; v3[16] ^= v6; v3[17] ^= v3[35]; v3[18] ^= v3[36]; v3[19] ^= v3[37]; v3[20] ^= v3[38]; v3[21] ^= v3[39]; v3[22] ^= v3[40]; v3[23] ^= v3[41]; v3[24] ^= v3[42]; v3[25] ^= v3[43]; v3[26] ^= v3[44]; v3[27] ^= v3[45]; v3[28] ^= v3[46]; v3[29] ^= v3[47]; v3[30] ^= v3[48]; v3[31] ^= v3[49]; v3[32] ^= v6; v3[33] ^= v3[35]; v7 = 0i64; v8 = v3 - byte_140004508; while ( byte_140004508[v7] == byte_140004508[v7 + v8] ) { if ( ++v7 \u0026gt;= 34 ) { v9 = \u0026#34;Nice. Now go get your presents :D\u0026#34;; goto LABEL_10; } } v9 = \u0026#34;Just a few more crunches\u0026#34;; LABEL_10: sub_1400026E0(std::cout, (__int64)v9); *(__int64 *)((char *)var_buf + *(int *)(var_buf[0] + 4)) = (__int64)\u0026amp;std::ifstream::`vftable\u0026#39;; *(int *)((char *)\u0026amp;v10 + *(int *)(var_buf[0] + 4)) = *(_DWORD *)(var_buf[0] + 4) - 176; sub_140002190((__int64)\u0026amp;var_buf[2]); std::istream::~istream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;var_buf[3]); std::ios::~ios\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;var_buf[22]); result = 0; } else { sub_1400026E0(std::cout, (__int64)\u0026#34;1000 pushups\u0026#34;); result = -1; } return result; } Analysis and solution It is fairly obvious that after \u0026quot;Are you ready for [REDACTED]?\u0026quot; is printed, it will wait on user to provide an input. It will get the first line of the input and see if it is equal to \u0026ldquo;nimic_interesant\u0026rdquo;. Then, it will continue to read 34 bytes from the input stream and store it in Str1. We will call these 34 bytes user_input and \u0026ldquo;nimic_interesant\u0026rdquo; the key from here on.\nrelevant code:\nv4 = sub_1400026E0(std::cout, (__int64)\u0026#34;Are you ready for [REDACTED]?\u0026#34;); // cout \u0026lt;\u0026lt; \u0026#34;Are you ready for [REDACTED]?\u0026#34;  std::ostream::operator\u0026lt;\u0026lt;(v4, sub_1400028B0); std::istream::getline(std::cin, Str1, 40i64); // get the first line.  if ( !strcmp(Str1, \u0026#34;nimic_interesant\u0026#34;) ) { strcpy_s(v3 + 34, 0x11ui64, Str1); // v3[34]+ nimic_interesant  memset(var_buf, 0, sizeof(var_buf)); sub_140002240((__int64)var_buf); // populate the var_buf  if ( (*((_BYTE *)\u0026amp;var_buf[2] + *(int *)(var_buf[0] + 4)) \u0026amp; 6) != 0 ) sub_1400026E0(std::cout, (__int64)\u0026#34;50 burpees\u0026#34;); *(_OWORD *)Str1 = 0i64; v13 = 0i64; v14 = 0i64; std::istream::read(var_buf, Str1, 34i64); // get the rest of the input  ... } This is followed by a large chunk of xor operations:\nv6 = v3[34]; *v3 ^= v6; v3[1] ^= v3[35]; v3[2] ^= v3[36]; v3[3] ^= v3[37]; v3[4] ^= v3[38]; v3[5] ^= v3[39]; v3[6] ^= v3[40]; v3[7] ^= v3[41]; v3[8] ^= v3[42]; v3[9] ^= v3[43]; v3[10] ^= v3[44]; v3[11] ^= v3[45]; v3[12] ^= v3[46]; v3[13] ^= v3[47]; v3[14] ^= v3[48]; v3[15] ^= v3[49]; v3[16] ^= v6; v3[17] ^= v3[35]; v3[18] ^= v3[36]; v3[19] ^= v3[37]; v3[20] ^= v3[38]; v3[21] ^= v3[39]; v3[22] ^= v3[40]; v3[23] ^= v3[41]; v3[24] ^= v3[42]; v3[25] ^= v3[43]; v3[26] ^= v3[44]; v3[27] ^= v3[45]; v3[28] ^= v3[46]; v3[29] ^= v3[47]; v3[30] ^= v3[48]; v3[31] ^= v3[49]; v3[32] ^= v6; v3[33] ^= v3[35]; v3 is basically a 50 bytes buffer where the first 34 bytes are the user_input and the next 16 bytes are the key. It is essentially doing the following:\nfor i in range (34): user_input[i] = user_input[i] ^ key[i%16] Then, the while block following the xor operations:\nv7 = 0i64; v8 = v3 - byte_140004508; while ( byte_140004508[v7] == byte_140004508[v7 + v8] ) { if ( ++v7 \u0026gt;= 34 ) { v9 = \u0026#34;Nice. Now go get your presents :D\u0026#34;; goto LABEL_10; } } This is using v7 as an index and v8 is the offset from v3 to byte_140004508. In a way, \u0026amp;v3 == \u0026amp;byte_140004508[v8]. Understanding that, we can see it is checking if the first 34 bytes in v3 is the same as the first 34 bytes in byte_140004508. The bytes turned out to be:\n['0x36', '0x44', '0x20', '0x28', '0x30', '0x24', '0x27', '0x1', '0x3', '0x3a', '0xb', '0xa', '0x6', '0x46', '0x1c', '0x11', '0x31', '0x1b', '0x8', '0x8', '0x7', '0x26', '0x36', '0x8', '0x1b', '0x17', '0x2d', '0xd', '0x1c', '0x9', '0x1', '0x1c', '0x1', '0x14'] So, to get the expected input, we can use the following script\nkey = \u0026#34;nimic_interesant\u0026#34; expectedResult = [\u0026#39;0x36\u0026#39;, \u0026#39;0x44\u0026#39;, \u0026#39;0x20\u0026#39;, \u0026#39;0x28\u0026#39;, \u0026#39;0x30\u0026#39;, \u0026#39;0x24\u0026#39;, \u0026#39;0x27\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x3\u0026#39;, \u0026#39;0x3a\u0026#39;, \u0026#39;0xb\u0026#39;, \u0026#39;0xa\u0026#39;, \u0026#39;0x6\u0026#39;, \u0026#39;0x46\u0026#39;, \u0026#39;0x1c\u0026#39;, \u0026#39;0x11\u0026#39;, \u0026#39;0x31\u0026#39;, \u0026#39;0x1b\u0026#39;, \u0026#39;0x8\u0026#39;, \u0026#39;0x8\u0026#39;, \u0026#39;0x7\u0026#39;, \u0026#39;0x26\u0026#39;, \u0026#39;0x36\u0026#39;, \u0026#39;0x8\u0026#39;, \u0026#39;0x1b\u0026#39;, \u0026#39;0x17\u0026#39;, \u0026#39;0x2d\u0026#39;, \u0026#39;0xd\u0026#39;, \u0026#39;0x1c\u0026#39;, \u0026#39;0x9\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x1c\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x14\u0026#39;] expectedInput = \u0026#34;\u0026#34; for i in range(34): expectedInput += chr(int(expectedResult[i],16) ^ ord(key[i%len(key)])) print (expectedInput) And you will have the flag:\nX-MAS{Now_you're_ready_for_hohoho} \n","permalink":"https://nusgreyhats.org/posts/writeups/x-mas-ctf-2021-intensive-training/","summary":"Overview This is a straightforward and classic reverse engineering challenge. It is a windows console application that will validate user input and checks the flag entered. I will go into a bit more details since this is a write up for beginners rather than experienced reverse engineers.\n  Understanding the target The first step to reverse engineering is figuring out how the target binary is constructed. I don\u0026rsquo;t want to waste our time reversing a packer or .","title":"[X-MAS CTF 2021] Intensive Training"},{"content":"What is Server Side Request Forgery (SSRF)? It is a web security vulnerability that allows an attacker to induce a server side application to make a HTTP request to a domain of the attacker\u0026rsquo;s choosing.\nTypically, the attacker will target the server\u0026rsquo;s internal only services.\nWhy SSRF?   SSRF trend   Between 2017 to 2021, SSRF have been in the rise and is a new contender in the OWASP top 10.\nSome possible explainations might be the rise of the cloud and microservices architecture.\nA large amount of information today is hosted on the cloud to improve deployment times, high application uptimes as well as autoscaling with technologies such as kubernetes.\nWith the microservices architecture, big services are split up into multiple smaller microservices where each microservice is used to maintain one function of the larger services. The microservices usually communicate with each other over HTTP or other lightweight protocols.\nThis microservices architecture provides a large surface for the attacker to attempt to exploit SSRF. Any single vulnerable service will allow the attacker to access multiple microservices. With more services communicating with each other, the attacker will have a higher chance of finding a more impactful exploit.\nGeneral Impact The impact of SSRF is generally an attack on the server itself or other internal services that can be accessed from the server.\nHow does SSRF work?   SSRF   Although the attacker is unable to access the internal services directly, the attacker can still reach the other internal services through the vulnerable web servers.\nIn the diagram above, the attacker sends a malicious packet to the server to induce the server to make a request to other internal services (Either 1 or 2).\nThis usually occurs due to the lack of sanitization of user input especially when it comes to URLs. For example, if there is a web service that allows other users to convert a webpage into a PDF, the attacker can send the ip address of an internal service to view what is available on the other internal services.\nAn example of such a scenerio is CVE-2020-7740 which affects all versions of node-pdf-generator.\nIn this case, there is no sanitization of the user\u0026rsquo;s url before generating the PDF.\nfunction acceptHtmlAndProvidePdf(request, response) { console.log(\u0026#39;Request received: \u0026#39; + request); request.content = \u0026#39;\u0026#39;; request.addListener(\u0026#34;data\u0026#34;, function (chunk) { if (chunk) { request.content += chunk; } // Lack of checks here  }); request.addListener(\u0026#34;end\u0026#34;, function () { var options = { encoding: \u0026#39;utf-8\u0026#39;, pageSize: request.headers[\u0026#39;x-page-size\u0026#39;] || \u0026#39;Letter\u0026#39; }; response.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/pdf\u0026#39; }); htmlToPdf(request.content, options) .pipe(response); console.log(\u0026#39;Processed HTML to PDF: \u0026#39; + response); }); } This allows the attacker to forge a server request as the script fetches the information from the webpage to convert to PDF.\nWhat is the impact of SSRF The impact of SSRF can widely vary depending on different circumstances.\n Denial of Service Remote Code execution Bypassing access control Port Scanning: Reqeusts can be made to different ports and the resulting status code or result shown on the frontend allows the attacker to infer if the port is open Other internal services (Details on the attacks are given in the references below)  Redis: If Redis uses a text based protocol (RESP), the attacker can send a payload with the correct format and send commands to the redis server. Cloud metadata: Metadata API base url can be given to the vulnerable server to retrieve information about the server.    Types of SSRF There are mainly 3 different types of SSRF vulnerabilities.\n Basic SSRF: The result is returned to the frontend and can be seen by the user. Blind SSRF: The result of the attack is not returned to the frontend. Semi-Blind SSRF: The attacker only knows if the payload was successful or not. No details are given.  Comparison between Different Types of SSRF    Criteria Basic SSRF Blind SSRF Semi-Blind SSRF     Can the attacker directly view the page Yes No No   Difficulty of exploitation (In general) Lower Higher Medium    Example of a Basic SSRF An example of a basic SSRF exploit can be found here\nIn this example, the exposed service is running a PDF generation service. It takes in a URL from the user without sanitization and generates a PDF based on the link that it receives.\nWithin the same local environment, there is also another service that is running on localhost:5001 that contains a web server that is only accessible internally.\nBy passing the url of this internal service into the PDF generation service, the attacker can generate a PDF of the webpage that is hosted on the internal service.\nExample of a Blind SSRF An example of a blind SSRF exploit can be found here\nIn this example, the exposed service is a reporting server where users report suspicious attacks to the administrator.\nThe server automatically goes to the website and take a screenshot of the website before generating a markdown file for the admin to view.\nWhich this may seem like a good idea, a request from the server is forged in the process of taking the screenshot.\nAlthough this is harder to exploit compared to the basic SSRF, it can still lead to remote code execution under correct circumstances.\nMitigations for SSRF  Input validation (Sanitization) for URLs given by the user.  This can be in the form of a whitelist or a blacklist (There is a different list of caveats for blacklists) Verification that IP / Domain is not an internal IP address / invalid address.   Do not accept complete URLs from users. Firewall filters to prevent access of unauthorised domains  Bypasses for Mitigations However, for each the mitigations, there might be some bypasses which can be used to reduce the effectiveness of the mitigations.\n Usage of malformed URLs  {domain}@127.0.0.1 or 127.0.1 all redirects to localhost. There are multiple encodings of this url. Similar methods can be used for other urls.   DNS rebinding  The attacker can register a domain and point it to a non-blacklisted website. After the server checks that the domain is valid, the attacker can change it to point to an internal ip address. When the server visits the domain again, the server will visit the internal ip address. More information can be found below   Open Redirect  If there is another open redirection on the page, the open redirection can be used to bypass restrictions on the webpage.   Bypass via Redirection  There might be filtering when it comes to a URL. This can be used to bypass url filters by registering a valid url which bypasses the various types of filtering.   SSRF via Referrer header  Sometimes web applications make use of server side analytics software that tracks visitors. These software logs the referrer header in the request and actually visit the websites to analyze the contents of referrer sites.    References  Port Swigger OWASP Top 10 Wallarm Attacking Redis Through SSRF SSRF Exposes data of technology From SSRF to port scanner Hacktricks - SSRF Bypasses SSRF Bypass Cheatsheet SSRF DNS Rebinding SSRF Bypass techniques  ","permalink":"https://nusgreyhats.org/posts/writeups/ssrf/","summary":"What is Server Side Request Forgery (SSRF)? It is a web security vulnerability that allows an attacker to induce a server side application to make a HTTP request to a domain of the attacker\u0026rsquo;s choosing.\nTypically, the attacker will target the server\u0026rsquo;s internal only services.\nWhy SSRF?   SSRF trend   Between 2017 to 2021, SSRF have been in the rise and is a new contender in the OWASP top 10.","title":"Server Side Request Forgery"},{"content":"SageMath Installation Windows : https://www.sagemath.org/download-windows.html\nMac : https://www.sagemath.org/download-mac.html\nLinux : https://www.sagemath.org/download-linux.html\nAs the whole package is around 10GB, it takes quite some time to install the whole package.\nRunning Sage IDE After the installation, run sagemath in terminal by typing sage\n$ sage ┌────────────────────────────────────────────────────────────────────┐ │ SageMath version 9.4, Release Date: 2021-08-22 │ │ Using Python 3.9.5. Type \u0026#34;help()\u0026#34; for help. │ └────────────────────────────────────────────────────────────────────┘ sage: Color Scheme You can change the color scheme by typing the command\nsage: %colors Linux Valid schemes: ['NoColor', 'Linux', 'LightBG', 'Neutral', '']\nI find the Linux color scheme most suitable dark background terminal.\nRunning Sage from file You can run a sage file from the terminal with\n$ sage test.sage\nOr a python file with\nIn the python file, import sage by\nfrom sage.all import * ... Then run it with this command\n$ sage -python test.py\nSageMath syntax Althought SageMath uses syntax very identical to python, there are still some subtle difference between them.\nThe official documentation often uses syntax that is supported only in .sage file.\nCommon syntax difference\n   Behavior Sage Python     Exponent ^ **   XOR ^^ ^   Polynomial R.\u0026lt;x\u0026gt; = QQ[] QQ['x']   Multivariable Polynomial R.\u0026lt;x,y,z\u0026gt; = QQ[] QQ['x','y','z']    Most of the syntax are supported in both files\nThe best part of SageMath is that it provides simple syntax for many complex mathematical operations.\nRing and Field First, one must identify these symbols\n   Symbol Meaning Type     ZZ Integers Ring   QQ Rational Numbers Field   RR Real Numbers Field   CC Complex Numbers Field   Zmod(N) Integer Modulo N Ring   GF(N) Finite Field of size N Field    Note that for GF(N) the N must be $p^a$ where p is a prime.\nThe main differences between a ring and a field is\n Not all non-zero element in a Ring has an inverse. Ring might has zero divisor.  Take integer modulo 6 ring as an example\n The number 3 does not have inverse. There is no such number $a$ such that $3 \\cdot a \\equiv 1 \\mod 6$ The number 3 and 2 is a zero divisor. $3 \\cdot 2 \\equiv 0 \\mod 6$  You need to be very careful for the choice of your Ring/Field as some functions are only valid for field but not for ring.\nIn general, field are easier to work with as it has more properties. Most of the function that works for ring will work for field.\nTherefore, if you are dealing with integer modulo a prime number, you should use GF(p) instead of Zmod(p)\nOnce you convert a number to GF(p) or Zmod(p), you don\u0026rsquo;t have to keep applying % operator as the modulo operation will already be done automatically.\nsage: a = 63283 sage: b = 45342 sage: a = GF(17)(a) sage: b = GF(17)(b) sage: a + b 12 sage: a / b 3 sage: a^-1 2 sage: a^30 4 Operation +, -, *, ^ are well defined for Rings and Field.\nOpeartion / can be use if the element has an inverse\nFactor a number with the factor() function\nsage: a = 63283 sage: a.factor() 11^2 * 523 Polynomial Univariate Polynomial Recall the syntax to declare a polynomial is R.\u0026lt;x\u0026gt; = QQ[]\nR represents the Polynomial Ring\nx represents the variable\nQQ represents the ring for the coefficient of the polynomial.\nLet\u0026rsquo;s say you want to declare a polynomial such that the coefficient can only be an integer.\nThen it will be R.\u0026lt;x\u0026gt; = ZZ[]\nsage: R.\u0026lt;x\u0026gt; = ZZ[] sage: f = 1*x + 2*x^2 + 3*x^3 sage: g = 3*x + 10*x^2 You can use +, -, *, /, ^ for polynomials as usual\nsage: f-g 3*x^3 - 8*x^2 - 2*x sage: f*g 30*x^5 + 29*x^4 + 16*x^3 + 3*x^2 sage: f/g (3*x^2 + 2*x + 1)/(10*x + 3) sage: g^3 1000*x^6 + 900*x^5 + 270*x^4 + 27*x^3 Factor the polynomiak with factor()\nsage: f.factor() x * (3*x^2 + 2*x + 1) To apply some value to the polynomial, use the syntax f(x = 2) or f(2)\nsage: f(2) 34 sage: f(x=2) 34 To extract the coefficient of the polynomial, use list() function\nsage: g.list() [0, 3, 10] To get the roots of a polynomial, use roots() function\nf.roots() Note : This function is only defined for univariate polynomial in integer Ring or Field.\nMultivariate Polynomial Declaring the polynomial by R.\u0026lt;x,y\u0026gt; = QQ[]\nOperation +, -, *, /, ^ are well defined as usual\nsage: R.\u0026lt;x,y\u0026gt; = QQ[] sage: f = x + y + x*y sage: g = x^2 + y^2 sage: f + g x^2 + x*y + y^2 + x + y sage: f ^ -1 * g (x^2 + y^2)/(x*y + x + y) You can use f(x = 2, y = 3) to apply some value to the polynomial\nsage: f(x=3,y=5) 23 There are 2 ways that I use to solve system of equations\nResultant If the underlying ring for the polynomial is either integer ring or field, then you can use resultant to solve system of linear equations.\nsage: R.\u0026lt;x,y\u0026gt; = QQ[] sage: f = x + y + x*y sage: g = x^2 + y^2 sage: k = f.resultant(g, x) sage: k y^4 + 2*y^3 + 2*y^2 As roots() are only definied for univariate polynomial, we must change k to a univariate polynomial first.\nsage: k = k(x = 0) sage: k = k.univariate_polynomial() sage: k.roots() [(0, 2)] Groebner basis Groebner basis is much slower and less consistent. It might not find a solution for certain equations.\nBut as it works on any ring, sometimes we have no choice to use it especially when we are dealing with the ring of Integer modulo n.\nsage: R.\u0026lt;x,y\u0026gt; = Zmod(30)[] sage: f = x + y + 3 sage: g = 3 * x + y + 10 sage: I = Ideal([f,g]) sage: I.groebner_basis() [x + 26, y + 7, 15] Matrix You can declare a matrix by :\nsage: Matrix(ZZ, [[2,2,3],[4,2,5],[3,3,3]]) [2 2 3] [4 2 5] [3 3 3] sage: Matrix(GF(2), [[2,2,3],[4,2,5],[3,3,3]]) [0 0 1] [0 0 1] [1 1 1] The first parameter represents the underlying field for the entries of the matrix.\nAccess the entries of the matrix with the natural way\nsage: A = Matrix(ZZ, [[2,2,3],[4,2,5],[3,3,3]]) sage: A[2][1] 3 Operation +, -, *, ^ are well defined for a matrix\nOperation / is valid if the matrix is invertible\nOther functions for matrix includes :\nsage: A.rref() [1 0 0] [0 1 0] [0 0 1] sage: A.kernel() Free module of degree 3 and rank 0 over Integer Ring Echelon basis matrix: [] sage: A.charpoly() x^3 - 7*x^2 - 16*x - 6 Discrete Logarithm As long as you are dealing with a finite group, you can always use discrete_log() to find discrete logarithm.\nsage: a = GF(23)(10) sage: b = a^13 sage: discrete_log(b,a) 13 sage: K = GF(3^6,\u0026#39;x\u0026#39;) sage: x = K.gen() sage: a = x^3 + 3*x^2 + 2 sage: discrete_log(a, x) 299 sage: a = Matrix(GF(7), [[2,2,3],[4,2,5],[3,3,3]]) sage: b = a^3 sage: discrete_log(b,a) 3 Others There are other useful functions in SageMath such as\n Chinese Remainder Theorem Find multiplicative order Dealing with elliptic curve  You can learn how to use them by referring to the official documentation\n","permalink":"https://nusgreyhats.org/posts/guides/sage_note/","summary":"SageMath Installation Windows : https://www.sagemath.org/download-windows.html\nMac : https://www.sagemath.org/download-mac.html\nLinux : https://www.sagemath.org/download-linux.html\nAs the whole package is around 10GB, it takes quite some time to install the whole package.\nRunning Sage IDE After the installation, run sagemath in terminal by typing sage\n$ sage ┌────────────────────────────────────────────────────────────────────┐ │ SageMath version 9.4, Release Date: 2021-08-22 │ │ Using Python 3.9.5. Type \u0026#34;help()\u0026#34; for help. │ └────────────────────────────────────────────────────────────────────┘ sage: Color Scheme You can change the color scheme by typing the command","title":"SageMath guide"},{"content":"Zoom Link: https://nus-sg.zoom.us/meeting/register/tZAsduygpjsvEtKjXX3Wdid5-jBLVkt1mRMw\nTalk: 7:00pm-7:45pm Title: Source Engine code auditing adventure\nDescription In this talk I will talk about the Source Engine, the leaked codebase and how I audited it to find vulnerabilities. This also acts as a case study on how real life code bases are audited.\nRequirements The participants should have basic knowledge on C/C++, basic knowledge on x86 memory exploitation techniques, and how exploit mitigations (NX, ASLR, Stack Canaries) work.\nSpeaker Bio I\u0026rsquo;m Bien Pham, an offensive security engineer from the Sea Security Team. I\u0026rsquo;m known for finding vulnerabilities in Valve Corporation\u0026rsquo;s games, for instance, the Counter-Strike series. I also play CTFs, mostly handling pwn challenges.\n Talk: 7:45pm-8:30pm Title: SecWed Mini CTF\nDescription To end off Security Wednesdays for this semester, We will be having a mini CTF session where the participants will get time to try out different challenges.\nNearer to the end of the session, we will be going through the answers for each of the CTF challenges.\n ","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw0311/","summary":"Zoom Link: https://nus-sg.zoom.us/meeting/register/tZAsduygpjsvEtKjXX3Wdid5-jBLVkt1mRMw\nTalk: 7:00pm-7:45pm Title: Source Engine code auditing adventure\nDescription In this talk I will talk about the Source Engine, the leaked codebase and how I audited it to find vulnerabilities. This also acts as a case study on how real life code bases are audited.\nRequirements The participants should have basic knowledge on C/C++, basic knowledge on x86 memory exploitation techniques, and how exploit mitigations (NX, ASLR, Stack Canaries) work.","title":"SecWed #031121"},{"content":"During my internship, I reverse engineer macOS programs. So, I need a debugger.\nI am quite familiar with GDB, and there are nice extensions like GEF out there. However, Apple made it so difficult to compile a usable GDB on macOS\u0026hellip; 😑 We are pretty much forced to use LLDB (which I really don\u0026rsquo;t like).\nAnyways, beggars can\u0026rsquo;t be choosers, and vanilla GDB/LLDB is not really usable in the long run, so being able to use the scripting interface is very important. Similar to GDB, LLDB also has a Python scripting interface. Instead of .gdbinit, LLDB loads commands from .lldbinit during startup. There is a great lldbinit project that contains many custom commands which makes LLDB so much nicer to use, and I have a fork of it.\n(It is such a pain to even set breakpoints, vanilla LLDB is just not usable imo.)\nLLDB Architecture and Python Bindings Having the lldbinit extension is good. Being able to add my own custom commands is even better. To do so, I had to understand the architecture of the scripting interface.\nThe LLDB scripting interface is quite tidy. Everything is grouped into modules. Quoting the docs, here are less than half of the modules:\n SBAddress  A section + offset based address class.   SBBreakpoint  Represents a logical breakpoint and its associated settings.   SBBreakpointList  Proxy of C++ lldb::SBBreakpointList class   SBBreakpointLocation  Represents one unique instance (by address) of a logical breakpoint.   SBCommandInterpreter  SBCommandInterpreter handles/interprets commands for lldb.   SBCommandReturnObject  Represents a container which holds the result from command execution.    Feels like writing C++ but in Python. And the basic architecture is as follows:\nLLDB design: ------------| lldb -\u0026gt; debugger -\u0026gt; target -\u0026gt; process -\u0026gt; thread -\u0026gt; frame(s) -\u0026gt; thread -\u0026gt; frame(s)  LLDB talks to the debugger object debugger holds a target target holds a process process holds multiple threads and lastly, each thread has one or more frames  With more details (quoting the docs):\n SBTarget: Represents the target program running under the debugger.  Gives information about the executable, process, modules, memory, breakpoints, etc There\u0026rsquo;s a lot, check the docs   SBProcess: Represents the process associated with the target program.  Gives information about the process, memory Some overlap with the above, but this one doesn\u0026rsquo;t have modules nor breakpoints Check the docs   SBThread: Represents a thread of execution.  Gives information about a thread, e.g. thread ID Exposes functions for stepping (step in, step over, etc) and suspending/resuming Contains stack frame(s) (according to docs, it is possible to have more than 1, but I always see just 1) Check out the docs   SBFrame: Represents one of the stack frames associated with a thread.  Gives information about a stack frame, e.g. registers, functions, symbols, disassembly, etc This is a really useful module because of the information it gives. Check out the docs    Now, some useful functions to access the objects mentioned above (defined by lldbinit):\n SBTarget - get_target() SBProcess - get_process() SBThread - get_thread() SBFrame - get_frame()  Yea, quite easy.\nCreate Custom Commands To define a new command, it is as simple as creating a function in lldbinit.py. For example, to create a command called newcmd:\ndef cmd_newcmd(debugger, command, result, _dict): args = command.split(\u0026#39; \u0026#39;) if len(args) \u0026lt; 1: print(\u0026#39;newcmd \u0026lt;expression\u0026gt;\u0026#39;) return ... Then, the function must be registered as a command in the __lldb_init_module method:\ndef __lldb_init_module(debugger, internal_dict): ... ci.HandleCommand(\u0026#34;command script add -f lldbinit.cmd_newcmd newcmd\u0026#34;, res) ... The function name can be anything, but by convention all command functions in lldbinit go by cmd_\u0026lt;command name\u0026gt;.\nThe function arguments result and _dict might be useful but I don\u0026rsquo;t use them. debugger is the LLDB debugger object mentioned earlier, and command is the exact command string entered by the user.\nWe can use the API listed above to obtain information about the target/process/thread/frame, or perform actions such as setting breakpoints, stepping through instructions, etc.\nExample 1: Reading Memory Here\u0026rsquo;s a simple command I wrote to print unicode strings from memory (similar to x/s but printing unicode strings).\ndef cmd_xu(debugger, command, result, _dict): args = command.split(\u0026#39; \u0026#39;) if len(args) \u0026lt; 1: print(\u0026#39;xu \u0026lt;expression\u0026gt;\u0026#39;) return addr = int(get_frame().EvaluateExpression(args[0]).GetValue(), 10) error = lldb.SBError() ended = False s = u\u0026#39;\u0026#39; offset = 0 while not ended: mem = get_target().GetProcess().ReadMemory(addr + offset, 100, error) for i in range(0, 100, 2): wc = mem[i+1] \u0026lt;\u0026lt; 8 | mem[i] s += chr(wc) if wc == 0: ended = True break offset += 100 print(s) Example 2: Alias It is also possible to make aliases for long commands. For example, an alias for disabling breakpoints, through the SBCommandInterpreter object obtained via the debugger.GetCommandInterpreter() method.\n# disable breakpoint number def cmd_bpd(debugger, command, result, dict): res = lldb.SBCommandReturnObject() debugger.GetCommandInterpreter().HandleCommand(\u0026#34;breakpoint disable \u0026#34; + command, res) print(res.GetOutput()) Example 3: Function Tracing Lastly, here is an example of a more complicated command I wrote to get the list of functions called by the target. This is useful when I am attaching LLDB to Safari, and want to know the functions in a library that were called by Safari when loading a webpage.\nFor example, to see the functions in CoreGraphics called when browsing Wikipedia:\n(lldbinit) cz CoreGraphics [+] Creating breakpoints for all symbols in CoreGraphics [+] Done creating breakpoints for all symbols in CoreGraphics 0x7fff2505d324: | CoreGraphics CGColorSpaceUsesExtendedRange |__ WebKit WebKit::ShareableBitmap::calculateBytesPerRow(WebCore::IntSize, WebKit::ShareableBitmap::Configuration const\u0026amp;) 0x7fff2504a997: | CoreGraphics CGColorSpaceGetNumberOfComponents |__ QuartzCore CABackingStorePrepareUpdates_(CABackingStore*, unsigned long, unsigned long, unsigned int, unsigned int, unsigned int, unsigned long long, CA::GenericContext*, UpdateState*) 0x7fff250496fc: | CoreGraphics CGColorSpaceRetain |__ QuartzCore CA::CG::IOSurfaceDrawable::IOSurfaceDrawable(__IOSurface*, unsigned int, unsigned int, CGColorSpace*, int, int, unsigned int, unsigned int) 0x7fff2549cd24: | CoreGraphics CFRetain |__ CoreGraphics CGColorSpaceRetain 0x7fff2504971c: | CoreGraphics cs_retain_count |__ CoreFoundation _CFRetain 0x7fff2504e3d8: | CoreGraphics CGColorSpaceRelease |__ QuartzCore CABackingStorePrepareUpdates_(CABackingStore*, unsigned long, unsigned long, unsigned int, unsigned int, unsigned int, unsigned long long, CA::GenericContext*, UpdateState*) 0x7fff2505fdd1: | CoreGraphics CGSNewEmptyRegion |__ QuartzCore CABackingStorePrepareUpdates_(CABackingStore*, unsigned long, unsigned long, unsigned int, unsigned int, unsigned int, unsigned long long, CA::GenericContext*, UpdateState*) ... def cmd_cz(debugger, command, result, _dict): args = command.split(\u0026#39; \u0026#39;) if len(args) \u0026lt; 1: print(\u0026#39;cov \u0026lt;module name\u0026gt;\u0026#39;) return module_name = args[0] target = debugger.GetSelectedTarget() module = find_module_by_name(get_target(), module_name) # to keep track of the breakpoints set bpmap = {} print(\u0026#34;[+] Creating breakpoints for all symbols in\u0026#34;, module_name) for symbol in module: sym_name = symbol.GetName() if sym_name.startswith(\u0026#34;os\u0026#34;) or \u0026#34;pthread\u0026#34; in sym_name or \u0026#34;lock\u0026#34; in sym_name or \u0026#34;operator\u0026#34; in sym_name: continue address = symbol.GetStartAddress().GetLoadAddress(target) bp = target.BreakpointCreateByAddress(address) bpmap[address] = bp print(\u0026#34;[+] Done creating breakpoints for all symbols in\u0026#34;, module_name) visited = [] while True: get_process().Continue() thread = get_thread() rip = int(str(get_frame().reg[\u0026#34;rip\u0026#34;].value), 16) if rip in visited: continue if rip not in bpmap.keys(): print(\u0026#34;[+] Dead\u0026#34;) # crashed or something break # disable breakpoint after reaching it one time bpmap[rip].SetEnabled(False) print(hex(rip) + \u0026#34;:\u0026#34;) for i in range(2): frame = thread.GetFrameAtIndex(i) symbol = frame.GetSymbol() module = frame.GetModule().GetFileSpec().GetFilename() print(\u0026#34;|\u0026#34; + \u0026#34;__\u0026#34; * i, module, symbol.GetName()) In this example, I created a breakpoint using target.BreakpointCreateByAddress(address), by using the SBSymbol methods to get a function\u0026rsquo;s address in the process. I also used the lldbinit helper function find_module_by_name to get a SBModule object given a module name.\nThere were more unmentioned API calls used by this command, read the code to learn more if you are interested.\nThat\u0026rsquo;s all. Hope you find this useful :D\nReferences:\n LLDB docs lldbinit  fork of peter\u0026rsquo;s  fork of gdbinit\u0026rsquo;s  fork of deroko\u0026rsquo;s        ","permalink":"https://nusgreyhats.org/posts/writeups/basic-lldb-scripting/","summary":"During my internship, I reverse engineer macOS programs. So, I need a debugger.\nI am quite familiar with GDB, and there are nice extensions like GEF out there. However, Apple made it so difficult to compile a usable GDB on macOS\u0026hellip; 😑 We are pretty much forced to use LLDB (which I really don\u0026rsquo;t like).\nAnyways, beggars can\u0026rsquo;t be choosers, and vanilla GDB/LLDB is not really usable in the long run, so being able to use the scripting interface is very important.","title":"Basic LLDB Scripting"},{"content":"Zoom Link: https://nus-sg.zoom.us/meeting/register/tZIqd-qhrzopH90kFVsa1_98fY1Yq9r-VetY\nTalk: 7:00pm-7:45pm Title: My OSCP Journey\nDescription OSCP (Offensive Security Certified Professional) is an entry-level certification by Offensive Security that recognizes a person\u0026rsquo;s skills in penetration testing techniques and methodologies. In this talk, Jia Le will be sharing his experience in tackling this notoriously difficult and hands-on certification.\nRead more about the certification here: https://www.offensive-security.com/pwk-oscp/\nSpeaker Bio Tan Jia Le is a Year 2 Information Security student at the National University of Singapore (NUS) and a member of NUS Greyhats. He has a keen passion for penetration testing and had obtained the Offensive Security Certified Professional (OSCP) certification earlier this year. During his free time, he enjoys following security trends on Twitter and reading about security research findings. He also participates in Capture-The-Flag (CTF) competitions and focuses towards web challenges.\n   Talk: 7:45pm-8:30pm Title: So you want to be a Malware Reverse Engineer (RE) ?\nA sharing of tips/lessons gathered from a 5 year old malware RE.\nSlides here\nDescription Do you know what to do when you receive a piece of binary? How can you tell if it\u0026rsquo;s malicious? What are the steps taken to analyze this binary? What are the tools and techniques you can apply to examine this binary? What pitfalls to avoid and overcome with some of these static and dynamic analysis tools? How do you go about extracting the IOCs(Indicators of compromise) from the binary? Many tools can be utilized to dissect malware, but do you know which is the most important and how to take care of it.\nThe talk will focus on Windows PE but the techniques could also be applied to other file formats. There won\u0026rsquo;t be anything that is tied to a particular malware family but the content of the talk is gathered from the lessons learned while \u0026lsquo;dancing\u0026rsquo; with malware samples.\nSpeaker Bio Mark is a malware reverse engineer since 2017. His job requires him to comb through tens of binaries every week. He focuses on taking apart malware to determine its evasion techniques and IOCs. He has to analyze binaries of multiple formats e.g. PE, ELF, Mach-O, doc, pdf.\nTo him, every piece of binary has a story waiting for a malware reverse engineer to tell it.\n ","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw2710/","summary":"Zoom Link: https://nus-sg.zoom.us/meeting/register/tZIqd-qhrzopH90kFVsa1_98fY1Yq9r-VetY\nTalk: 7:00pm-7:45pm Title: My OSCP Journey\nDescription OSCP (Offensive Security Certified Professional) is an entry-level certification by Offensive Security that recognizes a person\u0026rsquo;s skills in penetration testing techniques and methodologies. In this talk, Jia Le will be sharing his experience in tackling this notoriously difficult and hands-on certification.\nRead more about the certification here: https://www.offensive-security.com/pwk-oscp/\nSpeaker Bio Tan Jia Le is a Year 2 Information Security student at the National University of Singapore (NUS) and a member of NUS Greyhats.","title":"SecWed #271021"},{"content":"   Talk 1: 7 PM to 7:35 PM Title: Cryptography - Diophantine equation\nDescription Diophantine equation is an equation where only the integer solutions matter. This has shown up in various cryptographical schemes like RSA, Diffie Hellman Key Exchange, and Elliptic Curve Cryptography. In this talk, Kel Zin will analyze some interesting CTF problems related to diophantine equation.\nSpeaker Kel Zin is a Year 2 NUS Computer Science student and a member of Greyhats. He likes Crypto.\n Talk 2: 7:35 PM to 8 PM Title: A practical approach to Image Forensics\nDescription As the famous adage goes, \u0026ldquo;A picture is worth a thousand words\u0026rdquo;. Images are commonly used in the internet we consume everyday, from social media to work. In this talk, we explore examining what an image is and how forensics \u0026amp; security could apply.\nBio Chan Jian Hao is an Information Security student at the National University of Singapore (NUS) and a member of NUS Greyhats. He enjoys fiddling with malwares and the forensics analysis of them, while at times pwning machines for penetration testing. During his free time, he spends it mindlessly playing computer games trying to escape from elohell.\n Talk 3: 8 PM to 8:15 PM Title: Hoodwinked\nDescription Steganography is the art of misdirection. The main idea is to trick a suspecting observer into thinking that nothing is there, when everything is present in plain sight. In this talk, Nigel will cover: (1) what steganography is, (2) LSB-steganography and (3) its applications in digital watermarking.\nBio Nigel enjoys algorithmic problems and composing music, though he is not blessed enough to be good at either. Pre-covid, he would sometimes be spotted at the pool.\n Talk 4: 8:15 PM to 8:30 PM Title: An introduction to XXE attacks\nDescription As web applications become increasingly prevalent in this day and age, the potential for attackers to exploit web-based vulnerabilities in these applications becomes increasingly greater. In this talk, Brandon will touch on on XML External Entity (XXE) Attacks, a particular form of web-based attacks that is less well-known.\nBio Brandon is an Information Security student and a member of Greyhats. He enjoys working with web-based applications as well as learning about various web exploitation techniques.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw2010/","summary":"Talk 1: 7 PM to 7:35 PM Title: Cryptography - Diophantine equation\nDescription Diophantine equation is an equation where only the integer solutions matter. This has shown up in various cryptographical schemes like RSA, Diffie Hellman Key Exchange, and Elliptic Curve Cryptography. In this talk, Kel Zin will analyze some interesting CTF problems related to diophantine equation.\nSpeaker Kel Zin is a Year 2 NUS Computer Science student and a member of Greyhats.","title":"SecWed #201021"},{"content":"   Talk 1: 7:00pm-7:45pm Title: A Guide on Antivirus Evasion\nDownload Slides\nDescription Antivirus evasion is crucial in many cybersecurity research and operations. For example, red team exercises are often conducted in a hardened production environment. While open-source tools may help in the enumeration or exploitations of services, they are often detected and flagged by antivirus.\nIn this talk, we will look into manual and partially automated ways to achieve antivirus evasion. In addition, we will explore two case studies on evading detection of popular hacking tools - SharpHound and mimikatz.\nSpeaker Bio Glenice graduated from NUS Information Security in 2020 and is an alumnus of NUS Greyhats. She is currently working as an associate cybersecurity specialist at Government Technology Agency. Her work focuses on web security, cloud technology, and social engineering practices.\n Talk 2: 7:45pm-8:30pm Title: Dirty Deeds Done Dirt Cheap\nDescription What are real world bugs made of? A miserable pile of secrets. This talk is not about cool exploit techniques, nor is it about the latest bypass using complex machinery. In this talk, I present some of the cheapest no-brainer techniques that have been used to find security bugs that you as a security professional should know. We will uncover some of the dirtiest tricks people use to write software and how to break it. You won\u0026rsquo;t like what you see, but don\u0026rsquo;t hate the player, hate the game.\nSpeaker Bio Wai Tuck is a PhD student at SMU, focusing on the intersection between security and machine learning. He graduated from Carnegie Mellon University with a Masters in Information Security, where he actively participated in CTFs and worked on research in dynamic analysis of Javascript code. He also previously contributed to nmap, creating the first reliable scanning script for SambaCry. He is OSCP, OSCE, OSWP, and OSWE certified.\n ","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw1310/","summary":"Talk 1: 7:00pm-7:45pm Title: A Guide on Antivirus Evasion\nDownload Slides\nDescription Antivirus evasion is crucial in many cybersecurity research and operations. For example, red team exercises are often conducted in a hardened production environment. While open-source tools may help in the enumeration or exploitations of services, they are often detected and flagged by antivirus.\nIn this talk, we will look into manual and partially automated ways to achieve antivirus evasion.","title":"SecWed #131021"},{"content":"Talk: 7:00pm-8:30pm The presentation will introduce what a Security Operations Center (SOC) is, its typical mission and responsibilities, and the different roles that make up a SOC. The speakers will talk about the various components of a SOC and how they help one another effectively detect security threats.\nThey will also discuss security incidents and how we respond to them. Finally, they will conclude the presentation with a show and tell how they can acquire an infected or compromised machine and what forensic artifacts they can uncover for our investigations.\nSpeakers Dr. Choo Fai Cheong is a senior manager at UKG. He is a founding member of UKG’s APAC Security Operations Center, where he has helped build the UKG\u0026rsquo;s SOC in Singapore. Dr. Choo is responsible for the day-to-day security operations and leads the team on threat hunting, detection development, and incident response. Before joining UKG, he was a senior consultant at Mandiant, where he handled cyber security incidents and performed forensic analysis.\nIan Starr Esguerra is a Senior Security Analyst at UKG. He has recently joined UKG’s APAC Security Operations Center, where he is part of the team that ensures the company’s security by analyzing security events, conducting incident response and investigations. Before joining UKG, he was an Incident Response Analyst at Barclays, where he performed a similar role. He was also a Malware Analyst at different AntiVirus companies, where he did the analysis, detection, and reverse engineering of prevalent malware.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw0610/","summary":"Talk: 7:00pm-8:30pm The presentation will introduce what a Security Operations Center (SOC) is, its typical mission and responsibilities, and the different roles that make up a SOC. The speakers will talk about the various components of a SOC and how they help one another effectively detect security threats.\nThey will also discuss security incidents and how we respond to them. Finally, they will conclude the presentation with a show and tell how they can acquire an infected or compromised machine and what forensic artifacts they can uncover for our investigations.","title":"SecWed #061021"},{"content":"We are back with a brand new site!\n","permalink":"https://nusgreyhats.org/posts/new-site/","summary":"We are back with a brand new site!","title":"New Website"},{"content":"   Talk 1: 1900Hrs - 1945Hrs Talk Title: Unusual Applications of OpenAI in Cybersecurity\nOne of the most prominent examples of AI-generated synthetic media’s impact on cybersecurity is in the field of social engineering and information operations. However, AI language models can still pop up in interesting places. Could we use OpenAI to convert assembly to pseudocode while reverse-engineering binaries? How about locating vulnerabilities in code? Let’s dive down the rabbit hole of OpenAI’s API, covering the latest advanced features such as fine-tunes, searches, and classifications.\nPre-talk Preparations You may wish to read the AI Phishing Whitepaper published by Black Hat USA or watch the AI Phishing DEF CON talk.\nSpeaker Eugene hacks for good! From Amazon to Zendesk , he has helped secure products from a range of vulnerabilities. At the Government Technology Agency of Singapore (GovTech), he protects citizen data through offensive security research and penetration testing.\nWhile he focuses on application security and vulnerability research, he is also involved in a variety of domains such as artificial intelligence and social engineering. Prior to GovTech, he contributed to cyber defense projects with the Singapore Armed Forces and was awarded the Most Valuable Hacker title at HackerOne\u0026rsquo;s H1-213 live hacking event for the US Air Force, UK Ministry of Defense, and Verizon Media.\nHis work has been featured at top conferences such as Black Hat and DEF CON as well as industry publications like WIRED and The Daily Swig. He writes at https://spaceraccoon.dev/, where he shares tips and tricks from his white hat hacking journey, including zero-days in core npm packages (CVE-2020–7788) and office applications (CVE-2021-33035). He looks forward to growing and learning in the exciting world of cybersecurity.\n Talk 2: 1945Hrs - 2030Hrs Talk Title: How to get into CTFs\nCTF (Capture the Flag) competitions are contests of skills with the aim of defeating security to get access to the \u0026lsquo;flag\u0026rsquo; - a token that can be exchanged for points. CTFs are becoming more popular in Singapore with increased funding from the government, and due to more lucrative prize rewards. 1st Place prize has increased from $2,000 to $5,000 for CrossCTF, and DSO-NUS CTF 1st Place being $10,000, for example.\nSo, how does one participate in such competitions, and how does one win one? In this talk, we will go through the acquiring of skills, the mindset, and tactics necessary to win.\nSpeaker Akash is a Computer Science Student studying at NUS and a Member of Greyhats. He has participated in many CTF challenges and has a great amount of experience up his sleeve. He mainly focuses on Reverse Engineering and Pwn.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw1509/","summary":"Talk 1: 1900Hrs - 1945Hrs Talk Title: Unusual Applications of OpenAI in Cybersecurity\nOne of the most prominent examples of AI-generated synthetic media’s impact on cybersecurity is in the field of social engineering and information operations. However, AI language models can still pop up in interesting places. Could we use OpenAI to convert assembly to pseudocode while reverse-engineering binaries? How about locating vulnerabilities in code? Let’s dive down the rabbit hole of OpenAI’s API, covering the latest advanced features such as fine-tunes, searches, and classifications.","title":"SecWed #150921"},{"content":"   Talk 1: 1900HRs - 1945HRs Title: Identifying Bugs in Router Firmware at Scale with Taint Analysis\nDescription Taint analysis is a very useful technique in reverse engineering and bug hunting. For some common vulnerability classes such as command injection or buffer overflow, it can be tedious for a researcher to find them through manual reverse engineering. In this talk, Daniel will share about a tool that he helped develop during his internship, which uses taint analysis techniques to automate the process of finding such bugs in router firmware.\nBio Daniel is a Year 3 Computer Engineering student in NUS. He is currently an intern at STARLabs, to fulfil his Industrial Attachment programme requirement by the Faculty of Engineering. He is also a member of the Greyhats core team.\n Talk 2: 1945HRs - 2030HRs Title: The Spectre of Ransomware and the Criminal Underground\nDescription The Criminal Underground today is a vibrant ecosystem, with many Criminal Enterprises existing to support Big Game Hunting (BGH) Ransomware Operations.\nNotable to the past year is the emergence of Access Brokers supporting a variety of Criminal Adversaries, including the most prolific Ransomware Operators, with initial access into their target environments.Also, a number of dramatic shifts have been observed in the BGH space, including the exponential surge in the adoption of the Extortion and Data Leaks tactics and the rise of Ransomware-as-a-Service.\nThis talk strives to take a deep dive into these recent threat trends and offer the audience with useful insights to better defend your organisation against the spectre of Ransomware and eCrime.\nBio Aaron serves as a Strategic Threat Advisor at Crowdstrike. He is responsible for CrowdStrike’s Threat Intelligence business across Asia-Pacific (APAC). Prior to his current role, Aaron was an Intelligence Consultant at Recorded Future. He was responsible for the design and implementation of threat Intelligence strategies for Commercial and Government Accounts across APAC.\nAaron got his start in Security and Threat Intelligence in the Singapore Armed Forces as a Military Intelligence Officer. He concluded 12 years of Active Duty in 2019 and has served in multiple Command Appointments in classified Intelligence Units, and garnered Staff experience in the areas of Strategic Planning and Policy Development. In his penultimate tour of duty, Aaron was instrumental in establishing the Defence Cyber Organisation (DCO), which is akin to Singapore’s Cyber Command.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw0809/","summary":"Talk 1: 1900HRs - 1945HRs Title: Identifying Bugs in Router Firmware at Scale with Taint Analysis\nDescription Taint analysis is a very useful technique in reverse engineering and bug hunting. For some common vulnerability classes such as command injection or buffer overflow, it can be tedious for a researcher to find them through manual reverse engineering. In this talk, Daniel will share about a tool that he helped develop during his internship, which uses taint analysis techniques to automate the process of finding such bugs in router firmware.","title":"SecWed #080921"},{"content":"   Talk 1: 1900Hrs - 1945Hrs Talk Title: Cyber Risk Quantification: Let\u0026rsquo;s talk cyber risk\nCybersecurity have been growing in importance and frequently play a key role in organisations in this day and age. With the recent growth of cyber threats and implementation of new cybersecurity laws, the possibility and consequences of exploited cyber risks have increased exponentially as well. As cybersecurity specialists, how can we translate such costs and the benefits of new security controls into something that can be universally understood across the organisation? In this talk, Debbie will be giving a brief introduction into quantifying cyber risks and discuss how we, as cybersecurity specialists, can help our organisations make smarter cybersecurity investments.\nSpeaker Debbie is a final year undergraduate student at NUS, majoring in Information Security. She previously graduated from Nanyang Polytechnic with a Diploma in Cyber Security and Forensics. As part of her roles as CISO summer intern at UBS, Debbie contributed to a white paper on Cyber Risk Quantification.\n Talk 2: 1945Hrs - 2030Hrs Talk Title: Static code analysis with Semgrep\nStatic code analysis is a powerful tool in finding bugs in code. In this talk, we will show off the power of Semgrep, an open source static analysis tools, in matching complicated code patterns. The talk will demonstrate the power of the hundreds of community contributed Semgrep rules, provide a brief tutorial on writing custom Semgrep rules tailored to a code base, and discuss the various use cases where Semgrep can make a difference.\nSpeaker Terry is a security consultant at Centurion Information Security. He enjoys reverse engineering and fuzzing applications in his spare time.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw0109/","summary":"Talk 1: 1900Hrs - 1945Hrs Talk Title: Cyber Risk Quantification: Let\u0026rsquo;s talk cyber risk\nCybersecurity have been growing in importance and frequently play a key role in organisations in this day and age. With the recent growth of cyber threats and implementation of new cybersecurity laws, the possibility and consequences of exploited cyber risks have increased exponentially as well. As cybersecurity specialists, how can we translate such costs and the benefits of new security controls into something that can be universally understood across the organisation?","title":"SecWed #010921"},{"content":"Talk: 1900Hrs - 2030Hrs Talk Title: Cyber threat intelligence: Winning the war on cybercrime\nIn this session, Lionel Bruchez from the UBS AG Chief Information Security Office will introduce the latest cybercrime trends and how threat intelligence enables the organization to remain ahead of the game.\nBeyond traditional cyber defence, Lionel will also pave the way towards leveraging cyber intelligence to proactively identify market landscape, risks and investment opportunities to support firms’ revenue generation and growth opportunities.\nSpeaker Lionel Bruchez is the COO of the UBS Intelligence Center and deputy APAC Chief Information Security Officer (CISO). In his roles, Lionel focuses on generating a business context for cyber defence activities and providing strategic and tactical awareness to key decision-makers across the firm. Lionel currently oversees the development of the UBS CISO Market Insights and Business Advisory service with a key focus on leveraging cybersecurity to enable a competitive advantage for organizations and institutions. Lionel comes from an academic background in ETH Zürich and EPF Lausanne, where he specialized in Quantum Cryptography, probabilistic machine learning, and research on next-generation Internet architectures.\n ","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw2508/","summary":"Talk: 1900Hrs - 2030Hrs Talk Title: Cyber threat intelligence: Winning the war on cybercrime\nIn this session, Lionel Bruchez from the UBS AG Chief Information Security Office will introduce the latest cybercrime trends and how threat intelligence enables the organization to remain ahead of the game.\nBeyond traditional cyber defence, Lionel will also pave the way towards leveraging cyber intelligence to proactively identify market landscape, risks and investment opportunities to support firms’ revenue generation and growth opportunities.","title":"SecWed #250821"},{"content":"Talk 1: 1900HRs - 1945HRs Title: Defending Singapore’s Digital Borders\nDescription Cyberspace will be increasingly central to maintaining Singapore’s economic success and geopolitical relevance. As one of the most connected countries globally, Singapore’s connectivity and digitalisation will only continue to intensify under our Smart Nation initiative. At the same time, cyber threats continue to proliferate. We see a variety of cyber threats from terrorists, criminal, and state-sponsored organisations, especially as Covid-19 has forced many of us to work, learn, and play from home, on our mobile and electronic devices.\nMINDEF/SAF is responsible for enhancing Singapore’s security and sovereignty, no matter where the threats come from. Join us to find out more!\nBio COL Justiin Ang, is Head, Cyber Strategy and Policy Department, of the Defence Cyber Organisation. COL Ang serves as the principal advisor to the Defence Cyber Chief for all matters pertaining to development and implementation of cyber strategies and plans. Prior to this, COL Justiin Ang held the appointment of Director (Strategic Policy, Policy-Operations and Futures) in the Defence Policy Office, where he oversaw the development of strategies to guide MINDEF’s defence relations, as well as policy matters pertaining to the SAF’s operations. COL Justiin Ang joined the Defence Cyber Organisation in 2020 after graduating from Carnegie Mellon University with a Masters in Science in Information Security. An Army infantry officer by vocation, he has experience in policy, operations, and talent management, having served with MINDEF/SAF for more than 20 years.\n Talk 2: 1945HRs - 2030HRs Title: Adversarial Attack on Machine Learning Models\nDescription Machine learning models, especially deep neural networks, have achieved excellent performance in tasks such as image classification, object detection and natural language processing. Nonetheless, most machine learning models are vulnerable towards attacks using adversarial samples. A smallest perturbation on the input, such as change of a pixel’s value, could cause the model to give the wrong result. In this talk, I will give a brief introduction about some of the adversarial attacks and discuss what we can do to mitigate them.\nBio Jiyi graduated from NUS School of Computing in 2018 with first class honors. Currently, he is a part-time PhD student in NUS, working with Prof. Chang Ee-Chien on topics in machine learning security. He is also working as a research scientist in PayPal.\n ","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw1808/","summary":"Talk 1: 1900HRs - 1945HRs Title: Defending Singapore’s Digital Borders\nDescription Cyberspace will be increasingly central to maintaining Singapore’s economic success and geopolitical relevance. As one of the most connected countries globally, Singapore’s connectivity and digitalisation will only continue to intensify under our Smart Nation initiative. At the same time, cyber threats continue to proliferate. We see a variety of cyber threats from terrorists, criminal, and state-sponsored organisations, especially as Covid-19 has forced many of us to work, learn, and play from home, on our mobile and electronic devices.","title":"SecWed #180821"},{"content":"   Talk 1: 1900Hrs - 1945Hrs Talk Title: Greyhats Introduction\nDo you find yourself wondering what the Greyhats team is often up to? Want to get to know more about the information security industry? Want to further hone your information security skills? 🖥 🚀\nLearn more about NUS' first and only information security interest group and the various activities that we embark on together! Join us at our welcome tea on 11 August 2021 from 7pm to 8.30pm, and get to know some of us and our team\u0026rsquo;s work first hand! 👨‍💻👨‍💻👨‍💻👨‍💻\nSpeaker NUS GreyHats is a special interest group designed to spark students' interest in information security and advance the level of security proficiency towards the aim of contributing to the growing need for cyber defenders in the government and private sectors.\n Talk 2: 1945Hrs - 2030Hrs Talk Title: Enigma and Bombe: how they encrypt and how they decipher in WWII\nMost cybersecurity professionals probably are aware of the significant role of codebreakers in WWII, in particular the encryption device Enigma and the code-breaker Bombe that often appeared in popular media. So, what about the technical details? In this talk, I will describe the details of Enigma \u0026amp; Bombe, up to the point that we could simulate them. While the experiences on both machines likely shaped development of modern cryptography, we probably won’t need such electro-mechanical system anymore. Nonetheless, it would be a fun topic to kickstart this seminar series.\nSpeaker Ee-Chien Chang is an Associate Professor in the School of Computing at National University of Singapore (NUS). He received his PhD in Computer Science from New York University and was a postdoctoral fellow with DIMACS in Rutgers University and NEC Labs America. His research focuses on cybersecurity security and is particularly intrigued by cross-domain problems. His earlier works include multimedia security, such as image forensic, image watermarking and biometric cryptography, which is in the intersection of multimedia and applied cryptography. More recently, he has been investigating issues on security of machine learning under adversarial environment, and application of the hardware-based Trusted Execution Environment in the cloud. He has published in reputable conferences and journals. He is a lead-PI of National Cybersecurity R\u0026amp;D Laboratory (NCL), NUS, and deputy director of the Centre for Technology, Robotics, Artificial Intelligence \u0026amp; the Law (TRAIL), NUS.\n","permalink":"https://nusgreyhats.org/posts/secweds/ay2122s1/sw1108/","summary":"Talk 1: 1900Hrs - 1945Hrs Talk Title: Greyhats Introduction\nDo you find yourself wondering what the Greyhats team is often up to? Want to get to know more about the information security industry? Want to further hone your information security skills? 🖥 🚀\nLearn more about NUS' first and only information security interest group and the various activities that we embark on together! Join us at our welcome tea on 11 August 2021 from 7pm to 8.","title":"SecWed #110821"},{"content":"","permalink":"https://nusgreyhats.org/resources/","summary":"resources","title":"Resources"},{"content":"","permalink":"https://nusgreyhats.org/secweds/","summary":"secweds","title":"Security Wednesdays"},{"content":"","permalink":"https://nusgreyhats.org/team/","summary":"team","title":"The Team"}]