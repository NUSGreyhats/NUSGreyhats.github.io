<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[DUCTF 2023] Encrypted Mail | NUS Greyhats</title>
<meta name=keywords content="writeups,ctf,crypto"><meta name=description content="DUCTF 2023: Encrypted Mail (Crypto) writeup."><meta name=author content="JuliaPoo"><link rel=canonical href=https://nusgreyhats.org/posts/writeups/ductf-2023-encrypted-mail/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap" rel=stylesheet><link crossorigin=anonymous href=/assets/css/stylesheet.e4254f3b072c9ef4a8b4b52fada0c77b35466f588dc08c9a754731e42fd054b5.css integrity="sha256-5CVPOwcsnvSotLUvraDHezVGb1iNwIyadUcx5C/QVLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://nusgreyhats.org/greyhats.png><link rel=icon type=image/png sizes=16x16 href=https://nusgreyhats.org/greyhats.png><link rel=icon type=image/png sizes=32x32 href=https://nusgreyhats.org/greyhats.png><link rel=apple-touch-icon href=https://nusgreyhats.org/greyhats.png><link rel=mask-icon href=https://nusgreyhats.org/greyhats.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nusgreyhats.org/posts/writeups/ductf-2023-encrypted-mail/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="[DUCTF 2023] Encrypted Mail"><meta property="og:description" content="DUCTF 2023: Encrypted Mail (Crypto) writeup."><meta property="og:type" content="article"><meta property="og:url" content="https://nusgreyhats.org/posts/writeups/ductf-2023-encrypted-mail/"><meta property="og:image" content="https://nusgreyhats.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-17T00:00:00+08:00"><meta property="article:modified_time" content="2023-10-17T00:00:00+08:00"><meta property="og:site_name" content="NUS Greyhats"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nusgreyhats.org/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[DUCTF 2023] Encrypted Mail"><meta name=twitter:description content="DUCTF 2023: Encrypted Mail (Crypto) writeup."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nusgreyhats.org/posts/"},{"@type":"ListItem","position":2,"name":"[DUCTF 2023] Encrypted Mail","item":"https://nusgreyhats.org/posts/writeups/ductf-2023-encrypted-mail/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[DUCTF 2023] Encrypted Mail","name":"[DUCTF 2023] Encrypted Mail","description":"DUCTF 2023: Encrypted Mail (Crypto) writeup.","keywords":["writeups","ctf","crypto"],"articleBody":"Metadata This challenge is from DownUnderCTF 2023. I played under NUS Greyhats instead of the usual SEE and we won 1st. However I didn’t really contribute much, I joined halfway through the CTF and had other commitments and accumulated a total of only ~1000/12000 of the eventual points the whole team made.\nRegardless, I’m happy that we blooded Encrypted Mail 31 hours into the CTF (beating SEE which I betrayed, sorryyyy Neobeo and Warri). Encrypted Mail was the 2nd hardest crypto challenge, and the hardest was, unfortunately for the author Joseph, unsolved.\nChallenge Points: 449 Solves: 3 Author: joseph Zero-knowledge authentication, end-to-end encryption, this new mail app has it all. For a limited time, admins may be sending flags to users. Sign up today to get yours!\nnc 2023.ductf.dev 30000\nObjective Players are given a minimal mail-server implementation to interact with. There are 4 options to choose from:\nRegister Login Send Message View Inbox When you register, the server asks for your username and your public key $y$ that will be used during Login. The intended usage of this mail server would require you to generate a private key $x$ and generate $y$ from it.\nDuring Login, the server prompts you with a series of challenges, which should require that you know the secret private key $x$ for that account to answer the challenges correctly. This is the “zero-knowledge” part of this mail server.\nOnce you log in, you can send messages and view your inbox. To send a message, you would need to input the recipient’s username. The server then replies with the recipient’s public key. You are then required to encrypt your message with the recipient’s public key, sign the message with your private key and tell the server the resulting encrypted message and signature.\nWhen you view your inbox, the server replies with all the messages you have. However, the server replies with the encrypted messages (encrypted with your public key) and the signatures (for you to verify the sender with the sender’s public key).\nIn addition to these functionalities, there are two bot accounts.\nadmin flag_haver The admin bot checks for any new accounts and sends them an (encrypted) sweet welcome message Welcome {username}!. The flag_haver bot iterates all the messages they have, and if the message is from admin (flag_haver checks the signature) and has the following format: Send flag to {username}, flag_haver obliges and sends the flag as an (encrypted) message to the user.\nflag_haver is the only account that has access to the flag, so we must get admin to send them Send flag to {username}. However, there’s nothing that prompts admin to do such a thing, so we probably have to log into admin.\nOnce we log into admin, it appears that we still need the admin’s private key to sign the message, so that flag_haver will happily read the message.\nAttack Logging into admin We start with first logging into admin. The code for this is implemented in Authenticator\ng = 3 p = 1467036926602756933667493250084962071646332827366282684436836892199877831990586034135575089582195051935063743076951101438328248410785708278030691147763296367303874712247063207281890660681715036187155115101762255732327814001244715367 class Authenticator: def __init__(self, pubkey): self.y = pubkey def generate_challenges(self, n=128): challenges = [] answers = [] for _ in range(n): b = round(random.random()) r = random.getrandbits(p.bit_length()) c = random.getrandbits(p.bit_length()) c1 = pow(g, r, p) if b == 0: c2 = pow(g, c, p) elif b == 1: c2 = pow(self.y, r, p) answers.append(b) challenges.append((int(c1), int(c2))) self.answers = answers return challenges def verify_answers(self, answers): return len(answers) == len(self.answers) and all(a == b for a, b in zip(answers, self.answers)) The authentication scheme is a zero-knowledge variant of Diffie-Hellman (I don’t know the actual name of this variant).\nThe user is expected to randomly generate a private key $x$ and compute their public key as $g^x = y ; \\mathrm{mod} ; p$ where $p$ is a prime and $g = 3$. $p$ is a strong prime so the Discrete Logarithm Problem (DLP) is hard on $\\mathbb{Z}/p\\mathbb{Z}$ is computationally hard.\nThe server knows a user’s public key $y$ and wants the user to prove that they know their private key (without actually transmitting the private key). The server generates $128$ challenges, for each challenge, it generates a boolean $b$, and random numbers $r, c \\in [0, p)$, and computes:\n$$ \\begin{aligned} c_1 \u0026= g^r \\text{ } \\mathrm{mod} \\text{ } p \\\\ c_2 \u0026= \\begin{cases} y^r = g^{x r} \\text{ } \\mathrm{mod} \\text{ } p \u0026 \\text{if b} \\\\ g^c \\text{ } \\mathrm{mod} \\text{ } p \u0026 \\text{otherwise} \\end{cases} \\end{aligned} $$\nThe server then returns $c_1$ and $c_2$ for each challenge, and the user is required to recover the value of $b$ for each challenge.\nSuppose the user doesn’t know the private key $x$. Then $g^c$ and $y ^r = g^{xr}$ are utterly indistinguishable as, due to the difficulty of DLP, a user won’t be able to recover $x$ from $y$, and hence $x r$ might as well be a random number just like $c$. The user is forced to guess the value of $b$ for each challenge, and since there are $128$ challenges, the probability of passing them all is $2^{-128}$, which is unreasonably small.\nHowever, if the user does know the private key $x$, the user can simply test if $c_1^x = c_2$ to get $b$.\nWe don’t know the admin’s private key, so we’re doomed right?\n$b$ isn’t random enough Let’s look at how the challenges are generated:\nimport random # ... def generate_challenges(self, n=128): challenges = [] answers = [] for _ in range(n): b = round(random.random()) r = random.getrandbits(p.bit_length()) c = random.getrandbits(p.bit_length()) c1 = pow(g, r, p) if b == 0: c2 = pow(g, c, p) elif b == 1: c2 = pow(self.y, r, p) answers.append(b) challenges.append((int(c1), int(c2))) self.answers = answers return challenges Recall that the user is to recover $b$ which should only be possible if they know their private key. However, $b$ is generated via Python’s random module, which uses a Pseudo-random number generator (PRNG) known as MT19937.\nMT19937 initialises an internal state $u$ of $624$ 32-bit integers, and at each step, it generates a “random” 32-bit integer. Note that b = round(random.random()) is just a fancy way of selecting a bit from one of the 32-bit outputs. Taking the $624$ 32-bit integer as a vector of $624 * 32 = 19938$ bits, i.e., $u \\in F_2^{19938}$ where $F_2 = \\mathbb{Z} / 2\\mathbb{Z}$ is the field of boolean, each 32-bit output $x_m \\in F_2^{32}$ is a linear transform of $u$. I.e., for each bit of output (say bit $b_n$ for the $n$-th challenge), we can associate a known vector $v_n$ such that $v_n^T u = b_n$.\nThis means that for $N$ challenges generated by the server, we can represent the vector $\\textbf{b} = (b_1 ; b_2 ; \\cdots ; b_N)$ with a known linear transformation $V u = \\textbf{b}$, where $V = (v_1 ; v_2 ; \\cdots ; v_N)$.\nThis is huge! If we know the value of vector $\\textbf{b}$ for a large enough $N$, we can recover $u$, and compute all subsequent $b_i = v_i^T u$. I.e., we can answer all subsequent challenges and log into any user without knowing their private key!\nI found this before the hint came up btw, but as I didn’t join the discord, I didn’t see the announcement calling for feedback :(.\nHow do we get $\\textbf{b}$? Since we can answer the challenges if we log into an account we created (since we know the private key), we can simply log in as many times as needed and save the answers for the challenges.\nFurthermore, $V$ is a transform $F_2^{19938} \\rightarrow F_2^{N}$. So, to solve for $u$ given the equation $V u = \\textbf{b}$, we need $N \\ge 19938$. Since we obtain $128$ values of $b_i$ each time we log in, we would need to log in $\\lceil 19938/128 \\rceil = 156$ times.\nSmall caveat, turns out, for large enough $N$, $V$ will always have a 32-bit (or 31? I forgot) kernel, which makes recovering the exact $u$ impossible. However, since for large enough $N$ the kernel remains the same, whichever $u$ that satisfies $V u = \\textbf{b}$ for $N \\ge 19938$ allows us to compute subsequent $b_i$. This was found experimentally and if anybody knows why (I suspect it’s the twisting) do let me know.\nWe can compute $V$ in a black-box manner. We go through each of the $19938$ basis vectors of $F_2^{19938}$ by setting only one bit (say the $i$-th) of $u$ and computing $\\textbf{b}$ given such $u$. $\\textbf{b}$ will be the $i$-th column vector of $V$.\ns = random.getstate() def login_sym(bidx, n=128): new_s = (s[0], (*[int(0) if i != bidx//32 else int(1)\u003c\u003cint(bidx%32) for i in range(624)], s[1][-1]), s[2]) random.setstate(new_s) ret = [] for _ in range(156): for _ in range(n): b = round(random.random()) r = random.getrandbits(p.bit_length()) c = random.getrandbits(p.bit_length()) ret.append(b) return ret # prng is our transform V that transforms the internal state u # into the challenge answers prng = np.zeros((624*32, 624*32), dtype=bool) for bidx in range(624*32): print(bidx, end=\"\\r\") prng[:,bidx] = login_sym(bidx) np.save(open(\"prng_transform.npy\", \"wb\"), prng) Once we have $\\textbf{b}$, we can recover $u$ and generate the answers for the next challenge to log into any account:\nprng = np.load(open(\"prng_transform.npy\", \"rb\")) prng_sage = matrix(GF(2), prng.astype(int)) # bits is our b we've gotten from logging in 156 times sol = prng_sage.solve_right(vector(GF(2), bits), check=False) bvrec = list(map(int, sol)) rec_s = (s[0], (*[reduce(lambda x,y: (x\u003c\u003c1)+y, bvrec[i*32:i*32+32][::-1]) for i in range(624)], s[1][-1]), s[2]) # Assert that we recovered u correctly random.setstate(rec_s) rec_bits = [b for _ in range(156) for b in login_local()] assert all(x == y for x,y in zip(bits, rec_bits)) # Locally generate the answers for the 128 challenges during the next login bb = login_local() myans = \" \".join(map(str, map(int, bb))).encode() This step was for me the most frustrating step. I recovered $V$ very quickly but spent at least 2 hours trying to coax numpy to do $F_2$ arithmetic. And then I gave up and loaded the matrix into sagemath. However, due to my potato computer, it takes over 20 minutes to load the matrix and after that sagemath becomes extremely unstable and crashes all the time. I ended up re-loading the matrix into sagemath at least 7 times.\nSending flag_haver a message from the admin account Now that we can log into admin, we have to send flag_haver a message. Unfortunately, we would have to sign the message with admin’s private key, which we still do not have.\ndef send(self, recipient_public_key, message): key = secrets.randbelow(2**128) key_enc = Encryptor(recipient_public_key).encrypt(key) key_enc = key_enc[0].to_bytes(96, 'big') + key_enc[1].to_bytes(96, 'big') ct = Cipher(key).encrypt(message) sig = Signer(self.private_key).sign(ct) return (key_enc + ct, sig) def receive(self, sender_public_key, ciphertext, sig): if len(ciphertext) \u003c 192: return False key_enc, ct = ciphertext[:192], ciphertext[192:] if not Verifier(sender_public_key).verify(ct, sig): return False key_enc0, key_enc1 = int.from_bytes(key_enc[:96], 'big'), int.from_bytes(key_enc[96:192], 'big') key = Decryptor(self.private_key).decrypt((key_enc0, key_enc1)) message = Cipher(key).decrypt(ct) return message To send a message, we randomly generate a key that gets encrypted with the recipient’s public key (we have this) into key_enc. The message gets encrypted with ct and the ct is signed with the sender’s private key (we don’t have this) to get sig. key_enc, ct and sig get sent.\nNote that the recipient will require their private key to decrypt key_enc to decrypt ct into the message, and they will also verify that ct is signed with the recipient’s private key. This should ensure that\nOnly the recipient can read the message The recipient can verify that the message is indeed from the sender. A key “weird” thing to note here is that the signature only verifies that ct is committed to the sender’s private key. key_enc isn’t. This means that while the recipient can verify that ct came from the sender, they can’t guarantee that key_enc is.\nThis means that we can:\nTake an existing encrypted and signed message sent by the admin to a user whose private key we know. In this case, it is the welcome message to the user MeowMeowMeow. Use the known private key to recover key. Modify key which in turn will change the result of the ct’s decryption. Re-encrypt key with our new recipient’s public key to get key_enc. Re-use the ct and sig from the message we got from admin and only change the key_enc. Send the modified message to the new recipient. The new recipient will successfully decrypt key_enc into our modified key due to step 4, the new recipient will think the message is indeed from admin since we did not change ct, and finally, the decrypted message will look different from what the admin has sent to MeowMeowMeow because we’ve modified key.\nNow the question is whether we can change key such that the decrypted message changes from Welcome MeowMeowMeow! to Send flag to {username} to be sent to flag_haver, where username can be anything matching [a-zA-Z0-9]{8,16} as we can simply create an account with that username and receive the flag from flag_haver. Note that the modified message has to be the same length, so username should have length $8$. To do that we need to see how Cipher(key).encrypt(message) works.\nAttacking the Cipher class Cipher: def __init__(self, key): self.n = 4 self.idx = self.n self.state = [(key \u003e\u003e (32 * i)) \u0026 0xffffffff for i in range(self.n)] def next(self): if self.idx == self.n: for i in range(self.n): x = self.state[i] v = x \u003e\u003e 1 if x \u003e\u003e 31: v ^= 0xa9b91cc3 if x \u0026 1: v ^= 0x38ab48ef self.state[i] = v ^ self.state[(i + 3) % self.n] self.idx = 0 v = self.state[self.idx] x0, x1, x2, x3, x4 = (v \u003e\u003e 31) \u0026 1, (v \u003e\u003e 24) \u0026 1, (v \u003e\u003e 18) \u0026 1, (v \u003e\u003e 14) \u0026 1, v \u0026 1 y = x0 + x1 + x2 + x3 + x4 self.idx += 1 return y \u0026 1 def next_byte(self): return int(''.join([str(self.next()) for _ in range(8)]), 2) def xor(self, A, B): return bytes([a ^ b for a, b in zip(A, B)]) def encrypt(self, message): return self.xor(message, [self.next_byte() for _ in message]) def decrypt(self, ciphertext): return self.xor(ciphertext, [self.next_byte() for _ in ciphertext]) We can see that Cipher generates a stream by bytes according to the key and XORs it with the message. An interesting thing to note is that the .next method, and hence the .next_byte method, computes their output by taking a linear combination of the bits of key. This is easily seen by noting that the only operations used to update self.state and return the next byte only involve XOR and bitshifts.\nThis is extremely similar to how MT19937 works, in that for a given message of $l$ bytes, we have an associated XOR stream $x \\in F_2^{8 l}$ such that $c = m + x$ where $c$ is the ciphertext and $m$ is the message. We also have a 128-bit key $k \\in F_2^{128}$, and we can derive a fixed transform $V: F_2^{128}\\rightarrow F_2^{8 l}$ mapping $V k = x$.\nFor our use-case, we want to keep $c = m + x$ constant and compute a new key $k’$ such that $V k = x’$ and $c = m’ + x’$, where $x’$ is the new byte stream and $m’$ is our target ciphertext. Note that\nWe know $k$ as this $k$ is from the welcome message and we can get $k$ by decrypting key_enc with our private key. We know $m$ as Welcome MeowMeowMeow!. We can control $m’$ and hence know $\\delta_m$ as well. Then since:\n$$ \\begin{aligned} c \u0026= m + x = m’ + x’ = (m + \\delta_m) + x’ \\\\ x’ \u0026= x - \\delta_m \\\\ V k’ \u0026= x’ = x - \\delta_m \\end{aligned} $$\nThen since we can compute $x - \\delta_m$, we can easily compute $k’$… provided $k’$ actually exists.\nIt turns out that while our desired $k’$ has $128$ dimensions, $V$ only has rank $121$. Practically, this means we can always find a $k’$ such that $x’$ matches $x - \\delta_m$ for the first $121$ bits, or ~$15$ bytes. I.e., a $k’$ such that $m$ matches $m’$ by ~$15$-bytes.\nUnfortunately, our target message Send flag to {username} has a minimum length of $21$ bytes since username has the constraints [a-zA-Z0-9]{8,16}, so we are $6$ bytes short. Put it another way, if we determine the first $2$ bytes of username, say username=XX??????, we are guaranteed to find $k’$ such that $m’$ will be Send flag to XX------, where - are just random bytes, and so XX------ isn’t guaranteed to satisfy the [a-zA-Z0-9]{8,16} constraint.\nHowever, we can bruteforce XX such that XX------ does indeed satisfy the constraint!\nWe can expect bruteforce to work. We bruteforce $2$ characters in [a-zA-Z0-9] which amounts to $62^2 = 3844$ possibilities. Now, the probability that the remaining $6$ characters does appear in [a-zA-Z0-9] is $(62/256)^{6}$ which is roughly one in $4955$, which is fairly close to $3844$. In the event that no such XX exists, we can try again with a different initial username (in the welcome message, which currently is MeowMeowMeow).\nIt turns out the username elSvxrjZ does work. In fact, it works regardless of what $k$ is, since if $\\exists k’$ such that $V k’ = x’ = x - \\delta_m = V k - \\delta_m$, then for a new encountered key $j$, we have\n$$ V j - \\delta_m = V k - \\delta_m - V (j - k) = V k’ - V (j - k) = V (\\delta_k + j) $$\nSo, we can set $j’ = \\delta_k + j$ as our new key.\nfrom itertools import product import re import numpy as np import random # Compute V V = [] for bidx in range(128): c = Cipher(1\u003c\u003cbidx) V.append([c.next() for _ in range(8*21)]) V = matrix(GF(2), np.array(V).T) msg = b'Welcome MeowMeowMeow!' allowed = \"1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\" for x,y in product(allowed, repeat=2): target = f'Send flag to {x+y}aaaaaa'.encode() ct = Cipher(key).encrypt(msg) bs = vector(GF(2), [*map(int, ''.join([format(m^^c, \"08b\") for m,c in zip(target, ct)]))]) kbits = V.solve_right(bs, check=False) key_rec = int(\"\".join(map(str, kbits))[::-1], 2) ctt = Cipher(key_rec).encrypt(target) tar = [x^^y for x,y in zip(ctt[15:], target[15:])] nt = [x^^y for x,y in zip(tar, ct[15:])] new_target = target[:15] + bytes(nt) assert Cipher(key_rec).encrypt(new_target) == ct try: if re.fullmatch(r'[a-zA-Z0-9]{8,16}', new_target.decode()[13:]): break except: pass print(new_target) # b'Send flag to elSvxrjZ' So, before we log into admin, we just have to create the user elSvxrjZ, log into admin and send the spoofed message (Send flag to elSvxrjZ) to flag_haver. flag_haver will send the flag to elSvxrjZ and we can log into elSvxrjZ and decrypt the flag with elSvxrjZ’s private key.\nSummary of attack Create an account with the username elSvxrjZ and save the private key. Create an account with the username MeowMeowMeow and save the private key. Log into MeowMeowMeow 156 times to get enough challenge answers to recover the random generator’s internal state. Save the welcome message the admin sent MeowMeowMeow. Locally generate the answers for the next login challenge to log into the admin without knowing the admin’s private key. Use the saved welcome message for MeowMeowMeow to fake a signed message from admin that tells flag_haver to send the flag to elSvxrjZ. flag_haver is prompted to send the flag to username elSvcrjZ. Log into elSvxrjZ and use elSvxrjZ’s private key to decrypt the message from flag_haver, which contains the flag. Flag: DUCTF{wait_its_all_linear_algebra?...always_has_been}\n","wordCount":"3190","inLanguage":"en","datePublished":"2023-10-17T00:00:00+08:00","dateModified":"2023-10-17T00:00:00+08:00","author":{"@type":"Person","name":"JuliaPoo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nusgreyhats.org/posts/writeups/ductf-2023-encrypted-mail/"},"publisher":{"@type":"Organization","name":"NUS Greyhats","logo":{"@type":"ImageObject","url":"https://nusgreyhats.org/greyhats.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nusgreyhats.org/ accesskey=h title="NUS Greyhats (Alt + H)"><img src=https://nusgreyhats.org/greyhats-dark.png alt aria-label=logo id=logo height=35>
<script>localStorage.getItem("pref-theme")==="light"?document.getElementById("logo").src="/greyhats.png":document.getElementById("logo").src="/greyhats-dark.png"</script>NUS Greyhats</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://slf.nusgreyhats.org title="about us"><span>about us</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://nusgreyhats.org/team title="the team"><span>the team</span></a></li><li><a href=https://nusgreyhats.org/secweds title=secweds><span>secweds</span></a></li><li><a href=https://nusgreyhats.org/resources/ title=resources><span>resources</span></a></li><li><a href=https://nusgreyhats.org/tags/ title=tags><span>tags</span></a></li><li><a href=https://nusgreyhats.org/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[DUCTF 2023] Encrypted Mail</h1><div class=post-description>DUCTF 2023: Encrypted Mail (Crypto) writeup.</div><div class=post-meta><span title='2023-10-17 00:00:00 +0800 +0800'>October 17, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;JuliaPoo&nbsp;|&nbsp;<a href=https://github.com/NUSGreyhats/NUSGreyhats.github.io/tree/master/content/posts/writeups/[DUCTF%202023]%20Encrypted%20Mail.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=metadata>Metadata<a hidden class=anchor aria-hidden=true href=#metadata>#</a></h2><p>This challenge is from <a href=https://github.com/DownUnderCTF/Challenges_2023_Public>DownUnderCTF 2023</a>. I played under <a href=https://nusgreyhats.org/>NUS Greyhats</a> instead of the usual <a href=https://seetf.sg/>SEE</a> and we won 1st. However I didn&rsquo;t really contribute much, I joined halfway through the CTF and had other commitments and accumulated a total of only ~1000/12000 of the eventual points the whole team made.</p><p>Regardless, I&rsquo;m happy that we blooded Encrypted Mail 31 hours into the CTF (beating SEE which I betrayed, sorryyyy Neobeo and Warri). Encrypted Mail was the 2nd hardest crypto challenge, and the hardest was, unfortunately for the author Joseph, unsolved.</p><h2 id=challenge>Challenge<a hidden class=anchor aria-hidden=true href=#challenge>#</a></h2><ul><li>Points: 449</li><li>Solves: 3</li><li>Author: <a href=https://github.com/josephsurin>joseph</a></li></ul><blockquote><p>Zero-knowledge authentication, end-to-end encryption, this new mail app has it all. For a limited time, admins may be sending flags to users. Sign up today to get yours!</p><p><code>nc 2023.ductf.dev 30000</code></p></blockquote><h3 id=objective>Objective<a hidden class=anchor aria-hidden=true href=#objective>#</a></h3><p>Players are given a minimal mail-server implementation to interact with. There are 4 options to choose from:</p><ol><li>Register</li><li>Login</li><li>Send Message</li><li>View Inbox</li></ol><p>When you register, the server asks for your username and your public key $y$ that will be used during Login. The intended usage of this mail server would require you to generate a private key $x$ and generate $y$ from it.</p><p>During Login, the server prompts you with a series of <em>challenges</em>, which should require that you know the secret private key $x$ for that account to answer the challenges correctly. This is the &ldquo;zero-knowledge&rdquo; part of this mail server.</p><p>Once you log in, you can send messages and view your inbox. To send a message, you would need to input the recipient&rsquo;s username. The server then replies with the recipient&rsquo;s public key. You are then required to encrypt your message with the recipient&rsquo;s public key, sign the message with your private key and tell the server the resulting encrypted message and signature.</p><p>When you view your inbox, the server replies with all the messages you have. However, the server replies with the encrypted messages (encrypted with your public key) and the signatures (for you to verify the sender with the sender&rsquo;s public key).</p><p>In addition to these functionalities, there are two bot accounts.</p><ol><li><code>admin</code></li><li><code>flag_haver</code></li></ol><p>The <code>admin</code> bot checks for any new accounts and sends them an (encrypted) sweet welcome message <code>Welcome {username}!</code>. The <code>flag_haver</code> bot iterates all the messages they have, and if the message is from <code>admin</code> (<code>flag_haver</code> checks the signature) and has the following format: <code>Send flag to {username}</code>, <code>flag_haver</code> obliges and sends the flag as an (encrypted) message to the user.</p><p><code>flag_haver</code> is the only account that has access to the flag, so we must get <code>admin</code> to send them <code>Send flag to {username}</code>. However, there&rsquo;s nothing that prompts <code>admin</code> to do such a thing, so we probably have to log into <code>admin</code>.</p><p>Once we log into <code>admin</code>, it appears that we still need the <code>admin</code>&rsquo;s private key to sign the message, so that <code>flag_haver</code> will happily read the message.</p><h2 id=attack>Attack<a hidden class=anchor aria-hidden=true href=#attack>#</a></h2><h3 id=logging-into-admin>Logging into admin<a hidden class=anchor aria-hidden=true href=#logging-into-admin>#</a></h3><p>We start with first logging into <code>admin</code>. The code for this is implemented in <code>Authenticator</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>g <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>1467036926602756933667493250084962071646332827366282684436836892199877831990586034135575089582195051935063743076951101438328248410785708278030691147763296367303874712247063207281890660681715036187155115101762255732327814001244715367</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Authenticator</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, pubkey):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> pubkey
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_challenges</span>(self, n<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>):
</span></span><span style=display:flex><span>        challenges <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        answers <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> round(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>            c1 <span style=color:#f92672>=</span> pow(g, r, p)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                c2 <span style=color:#f92672>=</span> pow(g, c, p)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                c2 <span style=color:#f92672>=</span> pow(self<span style=color:#f92672>.</span>y, r, p)
</span></span><span style=display:flex><span>            answers<span style=color:#f92672>.</span>append(b)
</span></span><span style=display:flex><span>            challenges<span style=color:#f92672>.</span>append((int(c1), int(c2)))
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>answers <span style=color:#f92672>=</span> answers
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> challenges
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_answers</span>(self, answers):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> len(answers) <span style=color:#f92672>==</span> len(self<span style=color:#f92672>.</span>answers) <span style=color:#f92672>and</span> all(a <span style=color:#f92672>==</span> b <span style=color:#66d9ef>for</span> a, b <span style=color:#f92672>in</span> zip(answers, self<span style=color:#f92672>.</span>answers))
</span></span></code></pre></div><p>The authentication scheme is a zero-knowledge variant of <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>Diffie-Hellman</a> (I don&rsquo;t know the actual name of this variant).</p><p>The user is expected to randomly generate a private key $x$ and compute their public key as $g^x = y ; \mathrm{mod} ; p$ where $p$ is a prime and $g = 3$. $p$ is a strong prime so the <a href=https://en.wikipedia.org/wiki/Discrete_logarithm#Cryptography>Discrete Logarithm Problem (DLP)</a> is hard on $\mathbb{Z}/p\mathbb{Z}$ is computationally hard.</p><p>The server knows a user&rsquo;s public key $y$ and wants the user to prove that they know their private key (without actually transmitting the private key). The server generates $128$ challenges, for each challenge, it generates a boolean $b$, and random numbers $r, c \in [0, p)$, and computes:</p><p>$$
\begin{aligned}
c_1 &= g^r \text{ } \mathrm{mod} \text{ } p \\
c_2 &= \begin{cases}
y^r = g^{x r} \text{ } \mathrm{mod} \text{ } p & \text{if b} \\
g^c \text{ } \mathrm{mod} \text{ } p & \text{otherwise}
\end{cases}
\end{aligned}
$$</p><p>The server then returns $c_1$ and $c_2$ for each challenge, and the user is required to recover the value of $b$ for each challenge.</p><p>Suppose the user doesn&rsquo;t know the private key $x$. Then $g^c$ and $y ^r = g^{xr}$ are utterly indistinguishable as, due to the difficulty of DLP, a user won&rsquo;t be able to recover $x$ from $y$, and hence $x r$ might as well be a random number just like $c$. The user is forced to guess the value of $b$ for each challenge, and since there are $128$ challenges, the probability of passing them all is $2^{-128}$, which is unreasonably small.</p><p>However, if the user does know the private key $x$, the user can simply test if $c_1^x = c_2$ to get $b$.</p><p>We don&rsquo;t know the admin&rsquo;s private key, so we&rsquo;re doomed right?</p><h3 id=b-isnt-random-enough>$b$ isn&rsquo;t random enough<a hidden class=anchor aria-hidden=true href=#b-isnt-random-enough>#</a></h3><p>Let&rsquo;s look at how the challenges are generated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_challenges</span>(self, n<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>):
</span></span><span style=display:flex><span>    challenges <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    answers <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> round(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>        c1 <span style=color:#f92672>=</span> pow(g, r, p)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            c2 <span style=color:#f92672>=</span> pow(g, c, p)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            c2 <span style=color:#f92672>=</span> pow(self<span style=color:#f92672>.</span>y, r, p)
</span></span><span style=display:flex><span>        answers<span style=color:#f92672>.</span>append(b)
</span></span><span style=display:flex><span>        challenges<span style=color:#f92672>.</span>append((int(c1), int(c2)))
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>answers <span style=color:#f92672>=</span> answers
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> challenges
</span></span></code></pre></div><p>Recall that the user is to recover $b$ which should only be possible if they know their private key. However, $b$ is generated via Python&rsquo;s <code>random</code> module, which uses a Pseudo-random number generator (PRNG) known as <a href=https://en.wikipedia.org/wiki/Mersenne_Twister>MT19937</a>.</p><p>MT19937 initialises an internal state $u$ of $624$ 32-bit integers, and at each step, it generates a &ldquo;random&rdquo; 32-bit integer. Note that <code>b = round(random.random())</code> is just a fancy way of selecting a bit from one of the 32-bit outputs. Taking the $624$ 32-bit integer as a vector of $624 * 32 = 19938$ bits, i.e., $u \in F_2^{19938}$ where $F_2 = \mathbb{Z} / 2\mathbb{Z}$ is the field of boolean, each 32-bit output $x_m \in F_2^{32}$ is a linear transform of $u$. I.e., for each bit of output (say bit $b_n$ for the $n$-th challenge), we can associate a known vector $v_n$ such that $v_n^T u = b_n$.</p><p>This means that for $N$ challenges generated by the server, we can represent the vector $\textbf{b} = (b_1 ; b_2 ; \cdots ; b_N)$ with a known linear transformation $V u = \textbf{b}$, where $V = (v_1 ; v_2 ; \cdots ; v_N)$.</p><p>This is huge! If we know the value of vector $\textbf{b}$ for a large enough $N$, we can recover $u$, and compute all subsequent $b_i = v_i^T u$. I.e., we can answer all subsequent challenges and log into any user without knowing their private key!</p><p>I found this before the hint came up btw, but as I didn&rsquo;t join the discord, I didn&rsquo;t see the announcement calling for feedback :(.</p><p>How do we get $\textbf{b}$? Since we can answer the challenges if we log into an account we created (since we know the private key), we can simply log in as many times as needed and save the answers for the challenges.</p><p>Furthermore, $V$ is a transform $F_2^{19938} \rightarrow F_2^{N}$. So, to solve for $u$ given the equation $V u = \textbf{b}$, we need $N \ge 19938$. Since we obtain $128$ values of $b_i$ each time we log in, we would need to log in $\lceil 19938/128 \rceil = 156$ times.</p><p>Small caveat, turns out, for large enough $N$, $V$ will always have a 32-bit (or 31? I forgot) kernel, which makes recovering the exact $u$ impossible. However, since for large enough $N$ the kernel remains the same, whichever $u$ that satisfies $V u = \textbf{b}$ for $N \ge 19938$ allows us to compute subsequent $b_i$. This was found experimentally and if anybody knows why (I suspect it&rsquo;s the twisting) do let me know.</p><p>We can compute $V$ in a black-box manner. We go through each of the $19938$ basis vectors of $F_2^{19938}$ by setting only one bit (say the $i$-th) of $u$ and computing $\textbf{b}$ given such $u$. $\textbf{b}$ will be the $i$-th column vector of $V$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>s <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getstate()
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>login_sym</span>(bidx, n<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>):
</span></span><span style=display:flex><span>    new_s <span style=color:#f92672>=</span> (s[<span style=color:#ae81ff>0</span>], (<span style=color:#f92672>*</span>[int(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>if</span> i <span style=color:#f92672>!=</span> bidx<span style=color:#f92672>//</span><span style=color:#ae81ff>32</span> <span style=color:#66d9ef>else</span> int(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>&lt;&lt;</span>int(bidx<span style=color:#f92672>%</span><span style=color:#ae81ff>32</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>624</span>)], s[<span style=color:#ae81ff>1</span>][<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]), s[<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>    random<span style=color:#f92672>.</span>setstate(new_s)
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>156</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> round(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>getrandbits(p<span style=color:#f92672>.</span>bit_length())
</span></span><span style=display:flex><span>            ret<span style=color:#f92672>.</span>append(b)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># prng is our transform V that transforms the internal state u</span>
</span></span><span style=display:flex><span><span style=color:#75715e># into the challenge answers</span>
</span></span><span style=display:flex><span>prng <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((<span style=color:#ae81ff>624</span><span style=color:#f92672>*</span><span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>624</span><span style=color:#f92672>*</span><span style=color:#ae81ff>32</span>), dtype<span style=color:#f92672>=</span>bool)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> bidx <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>624</span><span style=color:#f92672>*</span><span style=color:#ae81ff>32</span>):
</span></span><span style=display:flex><span>    print(bidx, end<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    prng[:,bidx] <span style=color:#f92672>=</span> login_sym(bidx)
</span></span><span style=display:flex><span>np<span style=color:#f92672>.</span>save(open(<span style=color:#e6db74>&#34;prng_transform.npy&#34;</span>, <span style=color:#e6db74>&#34;wb&#34;</span>), prng)
</span></span></code></pre></div><p>Once we have $\textbf{b}$, we can recover $u$ and generate the answers for the next challenge to log into any account:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>prng <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>load(open(<span style=color:#e6db74>&#34;prng_transform.npy&#34;</span>, <span style=color:#e6db74>&#34;rb&#34;</span>))
</span></span><span style=display:flex><span>prng_sage <span style=color:#f92672>=</span> matrix(GF(<span style=color:#ae81ff>2</span>), prng<span style=color:#f92672>.</span>astype(int))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># bits is our b we&#39;ve gotten from logging in 156 times</span>
</span></span><span style=display:flex><span>sol <span style=color:#f92672>=</span> prng_sage<span style=color:#f92672>.</span>solve_right(vector(GF(<span style=color:#ae81ff>2</span>), bits), check<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>bvrec <span style=color:#f92672>=</span> list(map(int, sol))
</span></span><span style=display:flex><span>rec_s <span style=color:#f92672>=</span> (s[<span style=color:#ae81ff>0</span>], (<span style=color:#f92672>*</span>[reduce(<span style=color:#66d9ef>lambda</span> x,y: (x<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>+</span>y, bvrec[i<span style=color:#f92672>*</span><span style=color:#ae81ff>32</span>:i<span style=color:#f92672>*</span><span style=color:#ae81ff>32</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>][::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>624</span>)], s[<span style=color:#ae81ff>1</span>][<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]), s[<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Assert that we recovered u correctly</span>
</span></span><span style=display:flex><span>random<span style=color:#f92672>.</span>setstate(rec_s)
</span></span><span style=display:flex><span>rec_bits <span style=color:#f92672>=</span> [b <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>156</span>) <span style=color:#66d9ef>for</span> b <span style=color:#f92672>in</span> login_local()]
</span></span><span style=display:flex><span><span style=color:#66d9ef>assert</span> all(x <span style=color:#f92672>==</span> y <span style=color:#66d9ef>for</span> x,y <span style=color:#f92672>in</span> zip(bits, rec_bits))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Locally generate the answers for the 128 challenges during the next login</span>
</span></span><span style=display:flex><span>bb <span style=color:#f92672>=</span> login_local()
</span></span><span style=display:flex><span>myans <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>.</span>join(map(str, map(int, bb)))<span style=color:#f92672>.</span>encode()
</span></span></code></pre></div><p>This step was for me the most frustrating step. I recovered $V$ very quickly but spent at least 2 hours trying to coax <code>numpy</code> to do $F_2$ arithmetic. And then I gave up and loaded the matrix into sagemath. However, due to my potato computer, it takes over 20 minutes to load the matrix and after that sagemath becomes extremely unstable and crashes all the time. I ended up re-loading the matrix into sagemath at least 7 times.</p><h3 id=sending-flag_haver-a-message-from-the-admin-account>Sending flag_haver a message from the admin account<a hidden class=anchor aria-hidden=true href=#sending-flag_haver-a-message-from-the-admin-account>#</a></h3><p>Now that we can log into <code>admin</code>, we have to send <code>flag_haver</code> a message. Unfortunately, we would have to sign the message with <code>admin</code>&rsquo;s private key, which we still do not have.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send</span>(self, recipient_public_key, message):
</span></span><span style=display:flex><span>    key <span style=color:#f92672>=</span> secrets<span style=color:#f92672>.</span>randbelow(<span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>128</span>)
</span></span><span style=display:flex><span>    key_enc <span style=color:#f92672>=</span> Encryptor(recipient_public_key)<span style=color:#f92672>.</span>encrypt(key)
</span></span><span style=display:flex><span>    key_enc <span style=color:#f92672>=</span> key_enc[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>to_bytes(<span style=color:#ae81ff>96</span>, <span style=color:#e6db74>&#39;big&#39;</span>) <span style=color:#f92672>+</span> key_enc[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>to_bytes(<span style=color:#ae81ff>96</span>, <span style=color:#e6db74>&#39;big&#39;</span>)
</span></span><span style=display:flex><span>    ct <span style=color:#f92672>=</span> Cipher(key)<span style=color:#f92672>.</span>encrypt(message)
</span></span><span style=display:flex><span>    sig <span style=color:#f92672>=</span> Signer(self<span style=color:#f92672>.</span>private_key)<span style=color:#f92672>.</span>sign(ct)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (key_enc <span style=color:#f92672>+</span> ct, sig)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>receive</span>(self, sender_public_key, ciphertext, sig):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(ciphertext) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>192</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    key_enc, ct <span style=color:#f92672>=</span> ciphertext[:<span style=color:#ae81ff>192</span>], ciphertext[<span style=color:#ae81ff>192</span>:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> Verifier(sender_public_key)<span style=color:#f92672>.</span>verify(ct, sig):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    key_enc0, key_enc1 <span style=color:#f92672>=</span> int<span style=color:#f92672>.</span>from_bytes(key_enc[:<span style=color:#ae81ff>96</span>], <span style=color:#e6db74>&#39;big&#39;</span>), int<span style=color:#f92672>.</span>from_bytes(key_enc[<span style=color:#ae81ff>96</span>:<span style=color:#ae81ff>192</span>], <span style=color:#e6db74>&#39;big&#39;</span>)
</span></span><span style=display:flex><span>    key <span style=color:#f92672>=</span> Decryptor(self<span style=color:#f92672>.</span>private_key)<span style=color:#f92672>.</span>decrypt((key_enc0, key_enc1))
</span></span><span style=display:flex><span>    message <span style=color:#f92672>=</span> Cipher(key)<span style=color:#f92672>.</span>decrypt(ct)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> message
</span></span></code></pre></div><p>To send a message, we randomly generate a <code>key</code> that gets encrypted with the recipient&rsquo;s public key (we have this) into <code>key_enc</code>. The <code>message</code> gets encrypted with <code>ct</code> and the <code>ct</code> is signed with the sender&rsquo;s private key (we don&rsquo;t have this) to get <code>sig</code>. <code>key_enc</code>, <code>ct</code> and <code>sig</code> get sent.</p><p>Note that the recipient will require their private key to decrypt <code>key_enc</code> to decrypt <code>ct</code> into the message, and they will also verify that <code>ct</code> is signed with the recipient&rsquo;s private key. This should ensure that</p><ol><li>Only the recipient can read the message</li><li>The recipient can verify that the message is indeed from the sender.</li></ol><p>A key &ldquo;weird&rdquo; thing to note here is that the signature only verifies that <code>ct</code> is <em>committed</em> to the sender&rsquo;s private key. <code>key_enc</code> isn&rsquo;t. This means that while the recipient can verify that <code>ct</code> came from the sender, they can&rsquo;t guarantee that <code>key_enc</code> is.</p><p>This means that we can:</p><ol><li>Take an existing encrypted and signed message sent by the <code>admin</code> to a user whose private key we know. In this case, it is the welcome message to the user <code>MeowMeowMeow</code>.</li><li>Use the known private key to recover <code>key</code>.</li><li>Modify <code>key</code> which in turn will change the result of the <code>ct</code>&rsquo;s decryption.</li><li>Re-encrypt <code>key</code> with our new recipient&rsquo;s public key to get <code>key_enc</code>.</li><li>Re-use the <code>ct</code> and <code>sig</code> from the message we got from <code>admin</code> and only change the <code>key_enc</code>.</li><li>Send the modified message to the new recipient.</li></ol><p>The new recipient will successfully decrypt <code>key_enc</code> into our modified key due to step 4, the new recipient will think the message is indeed from <code>admin</code> since we did not change <code>ct</code>, and finally, the decrypted message will look different from what the <code>admin</code> has sent to <code>MeowMeowMeow</code> because we&rsquo;ve modified <code>key</code>.</p><p>Now the question is whether we can change <code>key</code> such that the decrypted message changes from <code>Welcome MeowMeowMeow!</code> to <code>Send flag to {username}</code> to be sent to <code>flag_haver</code>, where <code>username</code> can be anything matching <code>[a-zA-Z0-9]{8,16}</code> as we can simply create an account with that username and receive the flag from <code>flag_haver</code>. Note that the modified message has to be the same length, so <code>username</code> should have length $8$. To do that we need to see how <code>Cipher(key).encrypt(message)</code> works.</p><h3 id=attacking-the-cipher>Attacking the Cipher<a hidden class=anchor aria-hidden=true href=#attacking-the-cipher>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cipher</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, key):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>idx <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>n
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>state <span style=color:#f92672>=</span> [(key <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#ae81ff>32</span> <span style=color:#f92672>*</span> i)) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffffffff</span> <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>n)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>idx <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>n):
</span></span><span style=display:flex><span>                x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>state[i]
</span></span><span style=display:flex><span>                v <span style=color:#f92672>=</span> x <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>:
</span></span><span style=display:flex><span>                    v <span style=color:#f92672>^=</span> <span style=color:#ae81ff>0xa9b91cc3</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                    v <span style=color:#f92672>^=</span> <span style=color:#ae81ff>0x38ab48ef</span>
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>state[i] <span style=color:#f92672>=</span> v <span style=color:#f92672>^</span> self<span style=color:#f92672>.</span>state[(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>n]
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>state[self<span style=color:#f92672>.</span>idx]
</span></span><span style=display:flex><span>        x0, x1, x2, x3, x4 <span style=color:#f92672>=</span> (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>, (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>24</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>, (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>18</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>, (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>, v <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> x0 <span style=color:#f92672>+</span> x1 <span style=color:#f92672>+</span> x2 <span style=color:#f92672>+</span> x3 <span style=color:#f92672>+</span> x4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>idx <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> y <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next_byte</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> int(<span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join([str(self<span style=color:#f92672>.</span>next()) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>8</span>)]), <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>xor</span>(self, A, B):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bytes([a <span style=color:#f92672>^</span> b <span style=color:#66d9ef>for</span> a, b <span style=color:#f92672>in</span> zip(A, B)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encrypt</span>(self, message):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>xor(message, [self<span style=color:#f92672>.</span>next_byte() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> message])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decrypt</span>(self, ciphertext):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>xor(ciphertext, [self<span style=color:#f92672>.</span>next_byte() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> ciphertext])
</span></span></code></pre></div><p>We can see that <code>Cipher</code> generates a stream by bytes according to the <code>key</code> and XORs it with the message. An interesting thing to note is that the <code>.next</code> method, and hence the <code>.next_byte</code> method, computes their output by taking a linear combination of the bits of <code>key</code>. This is easily seen by noting that the only operations used to update <code>self.state</code> and return the next byte only involve XOR and bitshifts.</p><p>This is extremely similar to how MT19937 works, in that for a given message of $l$ bytes, we have an associated XOR stream $x \in F_2^{8 l}$ such that $c = m + x$ where $c$ is the ciphertext and $m$ is the message. We also have a 128-bit key $k \in F_2^{128}$, and we can derive a fixed transform $V: F_2^{128}\rightarrow F_2^{8 l}$ mapping $V k = x$.</p><p>For our use-case, we want to keep $c = m + x$ constant and compute a new key $k&rsquo;$ such that $V k = x&rsquo;$ and $c = m&rsquo; + x&rsquo;$, where $x&rsquo;$ is the new byte stream and $m&rsquo;$ is our target ciphertext. Note that</p><ol><li>We know $k$ as this $k$ is from the welcome message and we can get $k$ by decrypting <code>key_enc</code> with our private key.</li><li>We know $m$ as <code>Welcome MeowMeowMeow!</code>.</li><li>We can control $m&rsquo;$ and hence know $\delta_m$ as well.</li></ol><p>Then since:</p><p>$$
\begin{aligned}
c &= m + x = m&rsquo; + x&rsquo; = (m + \delta_m) + x&rsquo; \\
x&rsquo; &= x - \delta_m \\
V k&rsquo; &= x&rsquo; = x - \delta_m
\end{aligned}
$$</p><p>Then since we can compute $x - \delta_m$, we can easily compute $k&rsquo;$&mldr; provided $k&rsquo;$ actually exists.</p><p>It turns out that while our desired $k&rsquo;$ has $128$ dimensions, $V$ only has rank $121$. Practically, this means we can always find a $k&rsquo;$ such that $x&rsquo;$ matches $x - \delta_m$ for the first $121$ bits, or ~$15$ bytes. I.e., a $k&rsquo;$ such that $m$ matches $m&rsquo;$ by ~$15$-bytes.</p><p>Unfortunately, our target message <code>Send flag to {username}</code> has a minimum length of $21$ bytes since <code>username</code> has the constraints <code>[a-zA-Z0-9]{8,16}</code>, so we are $6$ bytes short. Put it another way, if we determine the first $2$ bytes of <code>username</code>, say <code>username=XX??????</code>, we are guaranteed to find $k&rsquo;$ such that $m&rsquo;$ will be <code>Send flag to XX------</code>, where <code>-</code> are just random bytes, and so <code>XX------</code> isn&rsquo;t guaranteed to satisfy the <code>[a-zA-Z0-9]{8,16}</code> constraint.</p><p>However, we can bruteforce <code>XX</code> such that <code>XX------</code> does indeed satisfy the constraint!</p><p>We can expect bruteforce to work. We bruteforce $2$ characters in <code>[a-zA-Z0-9]</code> which amounts to $62^2 = 3844$ possibilities. Now, the probability that the remaining $6$ characters does appear in <code>[a-zA-Z0-9]</code> is $(62/256)^{6}$ which is roughly one in $4955$, which is fairly close to $3844$. In the event that no such <code>XX</code> exists, we can try again with a different initial username (in the welcome message, which currently is <code>MeowMeowMeow</code>).</p><p>It turns out the username <code>elSvxrjZ</code> does work. In fact, it works regardless of what $k$ is, since if $\exists k&rsquo;$ such that $V k&rsquo; = x&rsquo; = x - \delta_m = V k - \delta_m$, then for a new encountered key $j$, we have</p><p>$$
V j - \delta_m = V k - \delta_m - V (j - k) = V k&rsquo; - V (j - k) = V (\delta_k + j)
$$</p><p>So, we can set $j&rsquo; = \delta_k + j$ as our new key.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> product
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Compute V</span>
</span></span><span style=display:flex><span>V <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> bidx <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>128</span>):
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> Cipher(<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span>bidx)
</span></span><span style=display:flex><span>    V<span style=color:#f92672>.</span>append([c<span style=color:#f92672>.</span>next() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>8</span><span style=color:#f92672>*</span><span style=color:#ae81ff>21</span>)])
</span></span><span style=display:flex><span>V <span style=color:#f92672>=</span> matrix(GF(<span style=color:#ae81ff>2</span>), np<span style=color:#f92672>.</span>array(V)<span style=color:#f92672>.</span>T)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;Welcome MeowMeowMeow!&#39;</span>
</span></span><span style=display:flex><span>allowed <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> x,y <span style=color:#f92672>in</span> product(allowed, repeat<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Send flag to </span><span style=color:#e6db74>{</span>x<span style=color:#f92672>+</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>aaaaaa&#39;</span><span style=color:#f92672>.</span>encode()
</span></span><span style=display:flex><span>    ct <span style=color:#f92672>=</span> Cipher(key)<span style=color:#f92672>.</span>encrypt(msg)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bs <span style=color:#f92672>=</span> vector(GF(<span style=color:#ae81ff>2</span>), [<span style=color:#f92672>*</span>map(int, <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join([format(m<span style=color:#f92672>^^</span>c, <span style=color:#e6db74>&#34;08b&#34;</span>) <span style=color:#66d9ef>for</span> m,c <span style=color:#f92672>in</span> zip(target, ct)]))])
</span></span><span style=display:flex><span>    kbits <span style=color:#f92672>=</span> V<span style=color:#f92672>.</span>solve_right(bs, check<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    key_rec <span style=color:#f92672>=</span> int(<span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(map(str, kbits))[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ctt <span style=color:#f92672>=</span> Cipher(key_rec)<span style=color:#f92672>.</span>encrypt(target)
</span></span><span style=display:flex><span>    tar <span style=color:#f92672>=</span> [x<span style=color:#f92672>^^</span>y <span style=color:#66d9ef>for</span> x,y <span style=color:#f92672>in</span> zip(ctt[<span style=color:#ae81ff>15</span>:], target[<span style=color:#ae81ff>15</span>:])]
</span></span><span style=display:flex><span>    nt <span style=color:#f92672>=</span> [x<span style=color:#f92672>^^</span>y <span style=color:#66d9ef>for</span> x,y <span style=color:#f92672>in</span> zip(tar, ct[<span style=color:#ae81ff>15</span>:])]
</span></span><span style=display:flex><span>    new_target <span style=color:#f92672>=</span> target[:<span style=color:#ae81ff>15</span>] <span style=color:#f92672>+</span> bytes(nt)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> Cipher(key_rec)<span style=color:#f92672>.</span>encrypt(new_target) <span style=color:#f92672>==</span> ct
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> re<span style=color:#f92672>.</span>fullmatch(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;[a-zA-Z0-9]{8,16}&#39;</span>, new_target<span style=color:#f92672>.</span>decode()[<span style=color:#ae81ff>13</span>:]):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>: <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(new_target)
</span></span><span style=display:flex><span><span style=color:#75715e># b&#39;Send flag to elSvxrjZ&#39;</span>
</span></span></code></pre></div><p>So, before we log into <code>admin</code>, we just have to create the user <code>elSvxrjZ</code>, log into <code>admin</code> and send the spoofed message (<code>Send flag to elSvxrjZ</code>) to <code>flag_haver</code>. <code>flag_haver</code> will send the flag to <code>elSvxrjZ</code> and we can log into <code>elSvxrjZ</code> and decrypt the flag with <code>elSvxrjZ</code>&rsquo;s private key.</p><h2 id=summary-of-attack>Summary of attack<a hidden class=anchor aria-hidden=true href=#summary-of-attack>#</a></h2><ol><li>Create an account with the username <code>elSvxrjZ</code> and save the private key.</li><li>Create an account with the username <code>MeowMeowMeow</code> and save the private key.</li><li>Log into <code>MeowMeowMeow</code> 156 times to get enough challenge answers to recover the random generator&rsquo;s internal state.</li><li>Save the welcome message the admin sent <code>MeowMeowMeow</code>.</li><li>Locally generate the answers for the next login challenge to log into the <code>admin</code> without knowing the <code>admin</code>&rsquo;s private key.</li><li>Use the saved welcome message for <code>MeowMeowMeow</code> to fake a signed message from <code>admin</code> that tells <code>flag_haver</code> to send the flag to <code>elSvxrjZ</code>.<ul><li><code>flag_haver</code> is prompted to send the flag to username <code>elSvcrjZ</code>.</li></ul></li><li>Log into <code>elSvxrjZ</code> and use <code>elSvxrjZ</code>&rsquo;s private key to decrypt the message from <code>flag_haver</code>, which contains the flag.</li></ol><p><strong>Flag</strong>: <code>DUCTF{wait_its_all_linear_algebra?...always_has_been}</code></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://nusgreyhats.org/tags/writeups/>Writeups</a></li><li><a href=https://nusgreyhats.org/tags/ctf/>Ctf</a></li><li><a href=https://nusgreyhats.org/tags/crypto/>Crypto</a></li></ul><nav class=paginav><a class=prev href=https://nusgreyhats.org/posts/secweds/ay2324s1/sw1810/><span class=title>« Prev</span><br><span>SecWed #181023</span>
</a><a class=next href=https://nusgreyhats.org/posts/secweds/ay2324s1/sw1110/><span class=title>Next »</span><br><span>SecWed #111023</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on twitter" href="https://twitter.com/intent/tweet/?text=%5bDUCTF%202023%5d%20Encrypted%20Mail&amp;url=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f&amp;hashtags=writeups%2cctf%2ccrypto"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f&amp;title=%5bDUCTF%202023%5d%20Encrypted%20Mail&amp;summary=%5bDUCTF%202023%5d%20Encrypted%20Mail&amp;source=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f&title=%5bDUCTF%202023%5d%20Encrypted%20Mail"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on whatsapp" href="https://api.whatsapp.com/send?text=%5bDUCTF%202023%5d%20Encrypted%20Mail%20-%20https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share [DUCTF 2023] Encrypted Mail on telegram" href="https://telegram.me/share/url?text=%5bDUCTF%202023%5d%20Encrypted%20Mail&amp;url=https%3a%2f%2fnusgreyhats.org%2fposts%2fwriteups%2fductf-2023-encrypted-mail%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://nusgreyhats.org/>NUS Greyhats</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),document.getElementById("logo").src="/greyhats.png"):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),document.getElementById("logo").src="/greyhats-dark.png")})</script></body></html>